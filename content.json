{"meta":{"title":"A Coder's Blog","subtitle":"有关计算机的点点滴滴","description":"哪怕天再高那又怎样，踮起脚尖就更靠近阳光","author":"刘哲","url":"http://liuzhe6.github.io"},"pages":[{"title":"categories","date":"2017-01-24T07:24:57.000Z","updated":"2017-01-24T07:25:12.785Z","comments":false,"path":"categories/index.html","permalink":"http://liuzhe6.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-01-24T07:22:46.000Z","updated":"2017-01-24T07:23:36.122Z","comments":false,"path":"tags/index.html","permalink":"http://liuzhe6.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android将数据存储到文件中","slug":"Android将数据存储到文件中","date":"2017-01-19T02:27:48.000Z","updated":"2017-01-19T02:28:59.296Z","comments":true,"path":"2017/01/19/Android将数据存储到文件中/","link":"","permalink":"http://liuzhe6.github.io/2017/01/19/Android将数据存储到文件中/","excerpt":"","text":"Android开发中存储文件文件默认存储位置为 /data/data//files/目录下的主要有两种模式可选，MODE_PRIVATE和MODE_APPEND。MODE_PRIVATE：是默认操作模式，表示当指定同样文件名的时候，所写的内容会覆盖原文件中的内容。MODE_APPEND：表示如果该文件已经存在，就往文件里面追加内容，不存在就创建新文件。 下面是一段简单的代码示例：```public void save(){ String data = “Data to save”; FileOutputStream out = null; BufferedWriter writer = null; try{ out = openFileOutput(“data”, Context.MODE_PRIVATE); writer = new BufferedWriter(new OutputStreamWriter(out)); writer.write(data); } catch (IOException e){ e.printStackTrace(); } finally { try{ if (writer != null){ writer.close(); } } catch (IOException e) { e.printStackTrace(); } }}","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://liuzhe6.github.io/tags/Android/"},{"name":"数据存储","slug":"数据存储","permalink":"http://liuzhe6.github.io/tags/数据存储/"}]},{"title":"XML简介","slug":"XML简介","date":"2017-01-18T11:41:04.000Z","updated":"2017-01-19T02:29:02.518Z","comments":true,"path":"2017/01/18/XML简介/","link":"","permalink":"http://liuzhe6.github.io/2017/01/18/XML简介/","excerpt":"","text":"XML简介什么是XML可扩展标记语言是一种很像超文本标记语言的标记语言。它的设计宗旨是传输数据，而不是显示数据。它的标签没有被预定义。您需要自行定义标签。它被设计为具有自我描述性。它是W3C的推荐标准。 XML 树结构XML 文档形成了一种树结构，它从“根部”开始，然后扩展到“枝叶”。一个 XML 文档实例XML 使用简单的具有自我描述性的语法：第一行是 XML 声明。它定义 XML 的版本 (1.0) 和所使用的编码 (ISO-8859-1 = Latin-1/西欧字符集)。下一行描述文档的根元素（像在说：“本文档是一个便签”）：&lt;note&gt; 接下来 4 行描述根的 4 个子元素（to, from, heading 以及 body）：1234to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt; 最后一行定义根元素的结尾：&lt;/note&gt; 从本例可以设想，该 XML 文档包含了 John 给 George 的一张便签。 XML 文档形成一种树结构XML 文档必须包含根元素。该元素是所有其他元素的父元素。XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。所有元素均可拥有子元素：12345&lt;root&gt; &lt;child&gt; &lt;subchild&gt;.....&lt;/subchild&gt; &lt;/child&gt;&lt;/root&gt; 父、子以及同胞等术语用于描述元素之间的关系。父元素拥有子元素。相同层级上的子元素成为同胞（兄弟或姐妹）。所有元素均可拥有文本内容和属性（类似 HTML 中）。 实例 上图表示下面的 XML 中的一本书：1234567891011121314151617181920&lt;bookstore&gt;&lt;book category=&quot;COOKING&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt; &lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt;&lt;book category=&quot;CHILDREN&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt;&lt;book category=&quot;WEB&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; 例子中的根元素是 。文档中的所有 元素都被包含在 中。 元素有 4 个子元素：、&lt; author&gt;、、。 XML 语法规则XML 的语法规则很简单，且很有逻辑。这些规则很容易学习，也很容易使用。所有 XML 元素都须有关闭标签在 HTML，经常会看到没有关闭标签的元素：12&lt;p&gt;This is a paragraph&lt;p&gt;This is another paragraph 在 XML 中，省略关闭标签是非法的。所有元素都必须有关闭标签：12&lt;p&gt;This is a paragraph&lt;/p&gt;&lt;p&gt;This is another paragraph&lt;/p&gt; XML 标签对大小写敏感XML 元素使用 XML 标签进行定义。XML 标签对大小写敏感。在 XML 中，标签 与标签 是不同的。必须使用相同的大小写来编写打开标签和关闭标签：123&lt;Message&gt;这是错误的。&lt;/message&gt;&lt;message&gt;这是正确的。&lt;/message&gt; XML 必须正确地嵌套在 HTML 中，常会看到没有正确嵌套的元素：&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt;在 XML 中，所有元素都必须彼此正确地嵌套：&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;在上例中，正确嵌套的意思是：由于 元素是在 元素内打开的，那么它必须在 元素内关闭。 XML 文档必须有根元素XML 文档必须有一个元素是所有其他元素的父元素。该元素称为根元素。12345&lt;root&gt; &lt;child&gt; &lt;subchild&gt;.....&lt;/subchild&gt; &lt;/child&gt;&lt;/root&gt; XML 的属性值须加引号与 HTML 类似，XML 也可拥有属性（名称/值的对）。在 XML 中，XML 的属性值须加引号。请研究下面的两个 XML 文档。第一个是错误的，第二个是正确的：12345678&lt;note date=08/08/2008&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;/note&gt; &lt;note date=&quot;08/08/2008&quot;&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;/note&gt; 在第一个文档中的错误是，note 元素中的 date 属性没有加引号。 实体引用在 XML 中，一些字符拥有特殊的意义。如果你把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。这样会产生 XML 错误：&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;为了避免这个错误，请用实体引用来代替 “&lt;” 字符：&lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt;在 XML 中，有 5 个预定义的实体引用： 注释：在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。 XML 中的注释在 XML 中编写注释的语法与 HTML 的语法很相似：&lt;!-- This is a comment --&gt; 在 XML 中，空格会被保留HTML 会把多个连续的空格字符裁减（合并）为一个：12HTML: Hello my name is David.输出: Hello my name is David. 在 XML 中，文档中的空格不会被删节。 XML元素XML 文档包含 XML 元素。什么是 XML 元素？XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。元素可包含其他元素、文本或者两者的混合物。元素也可以拥有属性。1234567891011121314&lt;bookstore&gt;&lt;book category=&quot;CHILDREN&quot;&gt; &lt;title&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt;&lt;book category=&quot;WEB&quot;&gt; &lt;title&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; 在上例中， 和 都拥有元素内容，因为它们包含了其他元素。 只有文本内容，因为它仅包含文本。在上例中，只有 元素拥有属性 (category=”CHILDREN”)。 XML 命名规则XML 元素必须遵循以下命名规则： 名称可以含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字符 “xml”（或者 XML、Xml）开始 名称不能包含空格 可使用任何名称，没有保留的字词。 最佳命名习惯使名称具有描述性。使用下划线的名称也很不错。名称应当比较简短，比如：，而不是：。避免 “-“ 字符。如果您按照这样的方式进行命名：”first-name”，一些软件会认为你需要提取第一个单词。避免 “.” 字符。如果您按照这样的方式进行命名：”first.name”，一些软件会认为 “name” 是对象 “first” 的属性。避免 “:” 字符。冒号会被转换为命名空间来使用（稍后介绍）。XML 文档经常有一个对应的数据库，其中的字段会对应 XML 文档中的元素。有一个实用的经验，即使用数据库的名称规则来命名 XML 文档中的元素。非英语的字母比如 éòá 也是合法的 XML 元素名，不过需要留意当软件开发商不支持这些字符时可能出现的问题。 XML 元素是可扩展的XML 元素是可扩展，以携带更多的信息。请看下面这个 XML 例子：12345&lt;note&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt; 让我们设想一下，我们创建了一个应用程序，可将 、 以及 元素提取出来，并产生以下的输出：12345MESSAGETo: GeorgeFrom: JohnDon&apos;t forget the meeting! 想象一下，之后这个 XML 文档作者又向这个文档添加了一些额外的信息：1234567&lt;note&gt;&lt;date&gt;2008-08-08&lt;/date&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt; 那么这个应用程序会中断或崩溃吗？不会。这个应用程序仍然可以找到 XML 文档中的 、 以及 元素，并产生同样的输出。XML 的优势之一，就是可以经常在不中断应用程序的情况进行扩展。 XML 属性XML 元素可以在开始标签中包含属性，类似 HTML。属性 (Attribute) 提供关于元素的额外（附加）信息。 XML 属性从 HTML，你会回忆起这个：&lt;img src=&quot;computer.gif&quot;&gt;。”src” 属性提供有关 元素的额外信息。在 HTML 中（以及在 XML 中），属性提供有关元素的额外信息：12&lt;img src=&quot;computer.gif&quot;&gt;&lt;a href=&quot;demo.asp&quot;&gt; 属性通常提供不属于数据组成部分的信息。在下面的例子中，文件类型与数据无关，但是对需要处理这个元素的软件来说却很重要：&lt;file type=&quot;gif&quot;&gt;computer.gif&lt;/file&gt; XML 属性必须加引号属性值必须被引号包围，不过单引号和双引号均可使用。比如一个人的性别，person 标签可以这样写：&lt;person sex=&quot;female&quot;&gt;或者这样也可以：&lt;person sex=&#39;female&#39;&gt;注释：如果属性值本身包含双引号，那么有必要使用单引号包围它，就像这个例子：&lt;gangster name=&#39;George &quot;Shotgun&quot; Ziegler&#39;&gt;或者可以使用实体引用：&lt;gangster name=&quot;George &amp;quot;Shotgun&amp;quot; Ziegler&quot;&gt; XML 元素 vs. 属性请看这些例子：12345678910&lt;person sex=&quot;female&quot;&gt; &lt;firstname&gt;Anna&lt;/firstname&gt; &lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt; &lt;person&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;firstname&gt;Anna&lt;/firstname&gt; &lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt; 在第一个例子中，sex 是一个属性。在第二个例子中，sex 则是一个子元素。两个例子均可提供相同的信息。没有什么规矩可以告诉我们什么时候该使用属性，而什么时候该使用子元素。我的经验是在 HTML 中，属性用起来很便利，但是在 XML 中，您应该尽量避免使用属性。如果信息感觉起来很像数据，那么请使用子元素吧。 我最喜欢的方式下面的三个 XML 文档包含完全相同的信息：第一个例子中使用了 date 属性：123456&lt;note date=&quot;08/08/2008&quot;&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt; 第二个例子中使用了 date 元素：1234567&lt;note&gt;&lt;date&gt;08/08/2008&lt;/date&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt; 第三个例子中使用了扩展的 date 元素（这是我的最爱）：1234567891011&lt;note&gt;&lt;date&gt; &lt;day&gt;08&lt;/day&gt; &lt;month&gt;08&lt;/month&gt; &lt;year&gt;2008&lt;/year&gt;&lt;/date&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt; 以上内容摘自 http://www.w3school.com.cn/xml/index.asp","categories":[],"tags":[{"name":"XML","slug":"XML","permalink":"http://liuzhe6.github.io/tags/XML/"}]},{"title":"jstl简介","slug":"jstl简介","date":"2017-01-18T11:16:30.000Z","updated":"2017-01-18T11:30:16.063Z","comments":true,"path":"2017/01/18/jstl简介/","link":"","permalink":"http://liuzhe6.github.io/2017/01/18/jstl简介/","excerpt":"","text":"JSP标准标签库JSTL核心标签核心标签是最常用的JSTL标签。引用核心标签库的语法如下：12&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; logo 格式化标签JSTL格式化标签用来格式化并输出文本、日期、时间、数字。引用格式化标签库的语法如下：12&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt; logo SQL标签JSTL SQL标签库提供了与关系型数据库（Oracle，MySQL，SQL Server等等）进行交互的标签。引用SQL标签库的语法如下：12&lt;%@ taglib prefix=&quot;sql&quot; uri=&quot;http://java.sun.com/jsp/jstl/sql&quot; %&gt; logo XML标签12&lt;%@ taglib prefix=&quot;x&quot; uri=&quot;http://java.sun.com/jsp/jstl/xml&quot; %&gt; 在使用xml标签前，你必须将XML 和 XPath 的相关包拷贝至你的\\lib下: XercesImpl.jar下载地址： http://www.apache.org/dist/xerces/j/ xalan.jar下载地址： http://xml.apache.org/xalan-j/index.html JSTL函数JSTL包含一系列标准函数，大部分是通用的字符串处理函数。引用JSTL函数库的语法如下：12&lt;%@ taglib prefix=&quot;fn&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; %&gt; logo 以上内容摘自 http://www.runoob.com/jsp/jsp-jstl.html","categories":[],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://liuzhe6.github.io/tags/jsp/"},{"name":"jstl","slug":"jstl","permalink":"http://liuzhe6.github.io/tags/jstl/"}]},{"title":"Ajax简介","slug":"Ajax简介","date":"2017-01-16T03:22:53.000Z","updated":"2017-01-18T10:44:42.663Z","comments":true,"path":"2017/01/16/Ajax简介/","link":"","permalink":"http://liuzhe6.github.io/2017/01/16/Ajax简介/","excerpt":"","text":"ajax开发AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。AJAX = 异步 JavaScript和XML（标准通用标记语言的子集）。AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个网页页面。 摘自百度百科 AJAX - 创建 XMLHttpRequest 对象XMLHttpRequest 是 AJAX 的基础。XMLHttpRequest 对象所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。创建 XMLHttpRequest 对象所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。创建 XMLHttpRequest 对象的语法：1variable=new XMLHttpRequest(); 老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：1variable=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); 为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：123456789var xmlhttp; if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; AJAX - 向服务器发送请求XMLHttpRequest 对象用于和服务器交换数据。向服务器发送请求如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：12xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,true);xmlhttp.send(); logo GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 GET 请求一个简单的 GET 请求：12xmlhttp.open(&quot;GET&quot;,&quot;demo_get.asp&quot;,true);xmlhttp.send(); 在上面的例子中，您可能得到的是缓存的结果。为了避免这种情况，请向 URL 添加一个唯一的 ID：12xmlhttp.open(&quot;GET&quot;,&quot;demo_get.asp?t=&quot; + Math.random(),true);xmlhttp.send(); 如果您希望通过 GET 方法发送信息，请向 URL 添加信息：12xmlhttp.open(&quot;GET&quot;,&quot;demo_get2.asp?fname=Bill&amp;lname=Gates&quot;,true);xmlhttp.send(); POST 请求一个简单 POST 请求：12xmlhttp.open(&quot;POST&quot;,&quot;demo_post.asp&quot;,true);xmlhttp.send(); 如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据：123xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.asp&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;fname=Bill&amp;lname=Gates&quot;); logo url - 服务器上的文件open() 方法的 url 参数是服务器上文件的地址：xmlhttp.open(&quot;GET&quot;,&quot;ajax_test.asp&quot;,true);该文件可以是任何类型的文件，比如 .txt 和 .xml，或者服务器脚本文件，比如 .asp 和 .php （在传回响应之前，能够在服务器上执行任务）。 异步 - True 或 False？AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true：xmlhttp.open(&quot;GET&quot;,&quot;ajax_test.asp&quot;,true);对于 web 开发人员来说，发送异步请求是一个巨大的进步。很多在服务器执行的任务都相当费时。AJAX 出现之前，这可能会引起应用程序挂起或停止。通过 AJAX，JavaScript 无需等待服务器的响应，而是： 在等待服务器响应时执行其他脚本 当响应就绪后对响应进行处理 Async = true当使用 async=true 时，请规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数：123456789xmlhttp.onreadystatechange=function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; &#125; &#125;xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,true);xmlhttp.send(); Async = false如需使用 async=false，请将 open() 方法中的第三个参数改为 false：xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,false);我们不推荐使用 async=false，但是对于一些小型的请求，也是可以的。请记住，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。注释：当您使用 async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可：123xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,false);xmlhttp.send();document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; AJAX - 服务器响应服务器响应如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 responseText 属性如果来自服务器的响应并非 XML，请使用 responseText 属性。responseText 属性返回字符串形式的响应，因此您可以这样使用：document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; responseXML 属性如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML 属性：请求 books.xml 文件，并解析响应： 12345678xmlDoc=xmlhttp.responseXML;txt=&quot;&quot;;x=xmlDoc.getElementsByTagName(&quot;ARTIST&quot;);for (i=0;i&lt;x.length;i++) &#123; txt=txt + x[i].childNodes[0].nodeValue + &quot;&lt;br /&gt;&quot;; &#125;document.getElementById(&quot;myDiv&quot;).innerHTML=txt; 以上内容来自 WSchool 点击","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://liuzhe6.github.io/tags/Ajax/"}]},{"title":"idea建立web service client时抛出SAXParseException解决办法","slug":"idea建立web-service-client时抛出SAXParseException解决办法","date":"2017-01-14T03:05:03.000Z","updated":"2017-01-14T03:07:06.975Z","comments":true,"path":"2017/01/14/idea建立web-service-client时抛出SAXParseException解决办法/","link":"","permalink":"http://liuzhe6.github.io/2017/01/14/idea建立web-service-client时抛出SAXParseException解决办法/","excerpt":"","text":"使用idea开发平台建立web service client抛出异常问题描述:抛出java.lang.AssertionError: org.xml.sax.SAXParseException; systemId: jar.. 问题原因:我使用的jdk版本为jdk8,而jdk8对jaxb-xjc-2.2.7有这个BUG,详细原因请点击查看 解决方法:在 jdk1.8.0/jre/lib 下创建一个文件 jaxp.properties,并且在文件中写下一句话javax.xml.accessExternalSchema = all 从CSDN整理并发表","categories":[],"tags":[{"name":"idea","slug":"idea","permalink":"http://liuzhe6.github.io/tags/idea/"},{"name":"web service client","slug":"web-service-client","permalink":"http://liuzhe6.github.io/tags/web-service-client/"},{"name":"异常","slug":"异常","permalink":"http://liuzhe6.github.io/tags/异常/"}]},{"title":"json语法","slug":"json语法","date":"2017-01-06T13:37:30.000Z","updated":"2017-01-06T13:37:43.076Z","comments":true,"path":"2017/01/06/json语法/","link":"","permalink":"http://liuzhe6.github.io/2017/01/06/json语法/","excerpt":"","text":"json语法JSON 语法是 JavaScript 语法的子集。JSON 语法规则 JSON 语法是 JavaScript 对象表示法语法的子集。数据在名称/值对中数据由逗号分隔花括号保存对象方括号保存数组JSON 名称/值对 JSON 数据的书写格式是：名称/值对。名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：&quot;firstName&quot; : &quot;John&quot;这很容易理解，等价于这条 JavaScript 语句：firstName = &quot;John&quot;JSON 值 JSON 值可以是：数字（整数或浮点数）字符串（在双引号中）逻辑值（true 或 false）数组（在方括号中）对象（在花括号中）nullJSON 对象 JSON 对象在花括号中书写：对象可以包含多个名称/值对：{ &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; }这一点也容易理解，与这条 JavaScript 语句等价：firstName = &quot;John&quot;lastName = &quot;Doe&quot;JSON 数组 JSON 数组在方括号中书写：数组可包含多个对象：1234567&#123;&quot;employees&quot;: [&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Anna&quot; , &quot;lastName&quot;:&quot;Smith&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Peter&quot; , &quot;lastName&quot;:&quot;Jones&quot; &#125;]&#125; 在上面的例子中，对象 “employees” 是包含三个对象的数组。每个对象代表一条关于某人（有姓和名）的记录。JSON 使用 JavaScript 语法 因为 JSON 使用 JavaScript 语法，所以无需额外的软件就能处理 JavaScript 中的 JSON。通过 JavaScript，您可以创建一个对象数组，并像这样进行赋值：例子12345var employees = [&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,&#123; &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;: &quot;Carter&quot; &#125;]; 可以像这样访问 JavaScript 对象数组中的第一项：employees[0].lastName;返回的内容是：Gates可以像这样修改数据：employees[0].lastName = &quot;Jobs&quot;;","categories":[],"tags":[{"name":"json","slug":"json","permalink":"http://liuzhe6.github.io/tags/json/"}]},{"title":"一个jsp向另一个jsp传值","slug":"一个jsp向另一个jsp传值","date":"2017-01-06T13:31:42.000Z","updated":"2017-01-06T13:31:51.966Z","comments":true,"path":"2017/01/06/一个jsp向另一个jsp传值/","link":"","permalink":"http://liuzhe6.github.io/2017/01/06/一个jsp向另一个jsp传值/","excerpt":"","text":"一个jsp向另一个jsp传值 通过jsp的内置对象—request对象获取参数：（1）通过超链接传参：例：把a.jsp中i的值传到b.jsp中：在a.jsp页面中的核心代码为:传参 （说明：给i赋值时也可以用jsp表达式，例如i=&lt;%变量名 %&gt;)在b.jsp页面中的核心代码为： 12&lt;%String j=request.getParameter(&quot;i&quot;); %&gt;&lt;%=j %&gt; （2）通过request.setAttribute()方法：例：把a.jsp中表单中的name的值传送到b.jsp中： 在a.jsp页面中的核心代码为：&lt;%request.setAttribute(name,&quot;Danny&quot;);%&gt;在b.jsp页面中的核心代码为：&lt;%String getName=request.getParameter(&quot;name&quot;); %&gt; （3）通过表单传参：例：把a.jsp中表单中的name的值传送到b.jsp中：在a.jsp页面中的核心代码为： 重要的是，在jsp脚本中是无法使用EL表达式的，但是可以替换1234&lt;% request.setAttribute(&quot;username&quot;, request.getAttribute(&quot;username&quot;)); request.setAttribute(&quot;email&quot;, request.getAttribute(&quot;email&quot;));%&gt;","categories":[],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://liuzhe6.github.io/tags/jsp/"}]},{"title":"JavaScript","slug":"JavaScript","date":"2017-01-06T13:15:55.000Z","updated":"2017-01-06T13:22:45.692Z","comments":true,"path":"2017/01/06/JavaScript/","link":"","permalink":"http://liuzhe6.github.io/2017/01/06/JavaScript/","excerpt":"","text":"JavaScriptJavaScript简介JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。在1995年时，由Netscape公司的Brendan Eich，在网景导航者浏览器上首次设计实现而成。因为Netscape与Sun合作，Netscape管理层希望它外观看起来像Java，因此取名为JavaScript。但实际上它的语法风格与Self及Scheme较为接近。为了取得技术优势，微软推出了JScript，CEnvi推出ScriptEase，与JavaScript同样可在浏览器上运行。为了统一规格，因为JavaScript兼容于ECMA标准，因此也称为ECMAScript。 戳这里 W3School学习网站 JavaScript：写入 HTML 输出实例12document.write(&quot;&lt;h1&gt;This is a heading&lt;/h1&gt;&quot;);document.write(&quot;&lt;p&gt;This is a paragraph&lt;/p&gt;&quot;); 提示：您只能在 HTML 输出中使用 document.write。如果您在文档加载后使用该方法，会覆盖整个文档。 JavaScript：对事件作出反应&lt;button type=&quot;button&quot; onclick=&quot;alert(&#39;Welcome!&#39;)&quot;&gt;点击这里&lt;/button&gt;alert() 函数在 JavaScript 中并不常用，但它对于代码测试非常方便。onclick 事件只是您即将在本教程中学到的众多事件之一。 JavaScript：改变 HTML 内容使用 JavaScript 来处理 HTML 内容是非常强大的功能。12x=document.getElementById(&quot;demo&quot;) //查找元素x.innerHTML=&quot;Hello JavaScript&quot;; //改变内容 您会经常看到 document.getElementByID(“some id”)。这个方法是 HTML DOM 中定义的。DOM（文档对象模型）是用以访问 HTML 元素的正式 W3C 标准。您将在本教程的多个章节中学到有关 HTML DOM 的知识。 JavaScript 与 Java 是两种完全不同的语言，无论在概念还是设计上。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://liuzhe6.github.io/tags/JavaScript/"}]},{"title":"JSP","slug":"JSP","date":"2017-01-06T12:45:24.000Z","updated":"2017-01-06T13:10:53.117Z","comments":true,"path":"2017/01/06/JSP/","link":"","permalink":"http://liuzhe6.github.io/2017/01/06/JSP/","excerpt":"","text":"JSP简介什么是JSPJSP全名为Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servlet设计，它[1] 是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP技术有点类似ASP技术，它是在传统的网页HTML（标准通用标记语言的子集）文件(.htm,.html)中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。 用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。 它实现了Html语法中的java扩展（以 &lt;%, %&gt;形式）。JSP与Servlet一样，是在服务器端执行的。通常返回给客户端的就是一个HTML文本，因此客户端只要有浏览器就能浏览。 Java Servlet是JSP的技术基础，而且大型的Web应用程序的开发需要Java Servlet和JSP配合才能完成。JSP具备了Java技术的简单易用，完全的面向对象，具有平台无关性且安全可靠，主要面向因特网的所有特点。 (详细介绍请查阅相关资料 这里就不一一介绍了) 第一个JSP第一个JSP程序语言学习入门的第一个程序一般都是输出”Hello World！”，JSP输出”Hello World！”代码如下所示:12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;第一个JSP程序&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% out.println(&quot;Hello World！&quot;); %&gt; &lt;/body&gt;&lt;/html&gt; JSP语法脚本程序脚本程序可以包含任意量的Java语句、变量、方法或表达式，只要它们在脚本语言中是有效的。脚本程序的语法格式：&lt;% 代码片段 %&gt;或者，您也可以编写与其等价的XML语句，就像下面这样： 代码片段任何文本、HTML标签、JSP元素必须写在脚本程序的外面。下面给出一个示例，同时也是本教程的第一个JSP示例：123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;br/&gt;&lt;%out.println(&quot;Your IP address is &quot; + request.getRemoteAddr());%&gt;&lt;/body&gt;&lt;/html&gt; 中文编码问题的解决如果我们要在页面正常显示中文，我们需要在 JSP 文件头部添加以下代码：&lt;&gt;12&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; 接下来我们将以上程序修改为：123456789101112131415&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;br/&gt;&lt;%out.println(&quot;你的 IP 地址 &quot; + request.getRemoteAddr());%&gt;&lt;/body&gt;&lt;/html&gt; 这样中文就可以正常显示了。 JSP表达式一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。由于表达式的值会被转化成String，所以您可以在一个文本行中使用表达式而不用去管它是否是HTML标签。表达式元素中可以包含任何符合Java语言规范的表达式，但是不能使用分号来结束表达式。JSP表达式的语法格式：&lt;%= 表达式 %&gt;程序示例：1234567891011121314&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; 今天的日期是: &lt;%= (new java.util.Date()).toLocaleString()%&gt;&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; JSP注释123456789101112131415&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%-- 该部分注释在网页中不会被显示--%&gt; &lt;p&gt; 今天的日期是: &lt;%= (new java.util.Date()).toLocaleString()%&gt;&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; 运行后得到以下结果：今天的日期是: 2017-1-6 20:39:30不同情况下使用注释的语法规则： 语法 描述 &lt;%– 注释 –%&gt; JSP注释，注释内容不会被发送至浏览器甚至不会被编译 HTML注释，通过浏览器查看网页源代码时可以看见注释内容 &lt;\\% 代表静态 &lt;%常量 %> 代表静态 %&gt; 常量 \\’ 在属性中使用的单引号 \\” 在属性中使用的双引号 JSP指令JSP指令用来设置与整个JSP页面相关的属性。JSP指令语法格式：&lt;%@ directive attribute=&quot;value&quot; %&gt; 指令 描述 &lt;%@ page … %&gt; 定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等 &lt;%@ include … %&gt; 包含其他文件 &lt;%@ taglib … %&gt; 引入标签库的定义，可以是自定义标签","categories":[],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://liuzhe6.github.io/tags/jsp/"}]},{"title":"jsp使用项目路径之外的图片方法","slug":"jsp使用项目路径之外的图片方法","date":"2016-08-06T10:21:53.000Z","updated":"2017-01-06T11:05:43.667Z","comments":true,"path":"2016/08/06/jsp使用项目路径之外的图片方法/","link":"","permalink":"http://liuzhe6.github.io/2016/08/06/jsp使用项目路径之外的图片方法/","excerpt":"","text":"一个java web项目，把图片放在项目目录或者tomcat目录 可能会出现一些问题，那么我们可以放在项目目录之外，甚至可以放到不同的磁盘上，那么就需要在tomcat设置虚拟目录。 在tomcat的conf/server.xml中设置虚拟路径在tomcat下的conf/server.xml中增加一个代码 在中间如下： 12&lt;!--增加的--path=&quot;/虚拟名&quot; docBase=&quot;虚拟路径&quot; -&gt; &lt;Context path=&quot;/virtual&quot; docBase=&quot;D:\\upload\\&quot; reloadable=&quot;true&quot;&gt;&lt;/Context&gt; 在jsp中这样使用 1&lt;img src=&quot;/virtual/1.jsp&quot;&gt;","categories":[],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://liuzhe6.github.io/tags/jsp/"}]},{"title":"JFinal上传图片及其重命名","slug":"JFinal上传图片及其重命名","date":"2016-08-01T09:34:12.000Z","updated":"2017-01-06T11:03:46.537Z","comments":true,"path":"2016/08/01/JFinal上传图片及其重命名/","link":"","permalink":"http://liuzhe6.github.io/2016/08/01/JFinal上传图片及其重命名/","excerpt":"","text":"一、表单处理12345&lt;form action=&quot;applicant/changeInformation&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; &gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;/form&gt; 二、在后台的配置我们需要在Controller中得到表单里的三个东西，因为我们在客户端的请求为multipart request(form 表单使用了enctype=”multipart/form-data”)， 那么必须先调用getFile系列的方法才能使用getPara系列的方法正常工作，因为multipart request需要通过getFile系列方法解析请求体中的数据，包括参数 我们设置上传文件的路径为“D:/Activity_Registration_System/user_img”那么，在jfinal的config中设置一个基础上传路径 123456789@Overridepublic void configConstant(Constants me) &#123; // TODO Auto-generated method stub PropKit.use(&quot;SQLConfig.txt&quot;); me.setDevMode(PropKit.getBoolean(&quot;devMode&quot;)); me.setViewType(ViewType.JSP); //设置上传的基础路径,设置在D盘的Activity_Registration_System文件夹下面 me.setBaseUploadPath(&quot;D:/Activity_Registration_System/&quot;);&#125; 三、在Controller里的配置接下来，在Controller里面得到文件以及数据，并把文件保存在这个目录下1234//先使用getFile()获得上传的文件,并存在 基础路径+user_img 这个绝对路径下面String realpath = &quot;user_img&quot;;UploadFile uf = getFile(&quot;header&quot;,realpath); 接下来获取其他数据1234String username = getPara(&quot;username&quot;);System.out.println(&quot;username:&quot;+username);String email = getPara(&quot;email&quot;);System.out.println(&quot;email:&quot;+email); 四、对刚刚已经上传成功的文件进行重命名12345678910111213141516171819//首先我们要获取文件的拓展名，所以要把文件原名称进行拆分String fileName = file.getName();String extName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)+ 1); //获取拓展名,按照 &quot;.&quot; 分隔开的最后一个字符串//接下来，获取刚刚上传的文件的局对路径String [] test = file.getPath().split(&quot;user_img&quot;);//这里之所以按user_img 进行分割是因为有个bug 如果按照\\进行分割，则应写为spilt(&quot;\\\\&quot;) 但是编译器会解析为按字符串\\\\进行分割，所以会出现问题String road = &quot;&quot;; for (int i = 0 ;i &lt; test.length;i++)&#123; if (i == test.length-1)&#123; break; &#125; road += test[i]; &#125; road += &quot;user_img\\\\&quot; + getSessionAttr(&quot;student_id&quot;)+&quot;.&quot; + extName;//我这里按照学号进行命名//此时road的值为 文件的 绝对路径 + 新名称file.renameTo(new File(road)); 这样，简单的单文件、数据上传以及重命名就完成了。 这是我的第一篇博客，欢迎大家批评指正","categories":[],"tags":[{"name":"JFinal","slug":"JFinal","permalink":"http://liuzhe6.github.io/tags/JFinal/"}]}]}