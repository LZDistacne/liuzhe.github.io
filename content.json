{"meta":{"title":"A Coder's Blog","subtitle":"有关计算机的点点滴滴","description":"哪怕天再高那又怎样，踮起脚尖就更靠近阳光","author":"刘哲","url":"http://liuzhe6.github.io"},"pages":[{"title":"tags","date":"2017-01-24T07:22:46.000Z","updated":"2017-01-24T07:23:36.122Z","comments":false,"path":"tags/index.html","permalink":"http://liuzhe6.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-01-24T07:24:57.000Z","updated":"2017-01-24T07:25:12.785Z","comments":false,"path":"categories/index.html","permalink":"http://liuzhe6.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-01-25T04:54:32.982Z","updated":"2017-01-25T04:52:55.907Z","comments":true,"path":"baidu_verify_e0OSN9VAuH.html","permalink":"http://liuzhe6.github.io/baidu_verify_e0OSN9VAuH.html","excerpt":"","text":"e0OSN9VAuH"}],"posts":[{"title":"Android显示手机图片","slug":"Android显示手机图片","date":"2017-02-08T08:33:32.000Z","updated":"2017-02-08T08:39:52.870Z","comments":true,"path":"2017/02/08/Android显示手机图片/","link":"","permalink":"http://liuzhe6.github.io/2017/02/08/Android显示手机图片/","excerpt":"","text":"点击按钮后1Button chooseFromAlbum = (Button) findViewById(R.id.choose_from_album);&#10; chooseFromAlbum.setOnClickListener(new View.OnClickListener() &#123;&#10; @Override&#10; public void onClick(View v) &#123;&#10;&#10; //&#22914;&#26524;&#27809;&#26377;&#35835;&#21644;&#20889;SD&#21345;&#26435;&#38480;&#26102;&#10; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123;&#10; ActivityCompat.requestPermissions(MainActivity.this, new String[] &#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125; ,1);&#10; &#125; else &#123;&#10; openAlbum();&#10; &#125;&#10; &#125;&#10; &#125;); 动态申请读写SD卡权限1&#10;//&#21160;&#24577;&#30003;&#35831;&#26435;&#38480; &#36820;&#22238;&#32467;&#26524;&#10;@Override&#10;public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123;&#10; switch (requestCode)&#123;&#10; case 1:&#10; if (grantResults.length &#62;0 &#38;&#38; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123;&#10; openAlbum();&#10; &#125; else &#123;&#10; Toast.makeText(MainActivity.this , &#34;You denied the permission&#34; , Toast.LENGTH_SHORT).show();&#10; &#125;&#10; break;&#10; default:&#10; break;&#10; &#125;&#10;&#125;&#10;&#10;private void openAlbum() &#123;&#10; Intent intent = new Intent(&#34;android.intent.action.GET_CONTENT&#34;);&#10; intent.setType(&#34;image/*&#34;);&#10; startActivityForResult(intent , CHOOSE_PHOTO);&#10;&#125; 对启动活动时返回结果的判断1@Override&#10; protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;&#10; switch (requestCode)&#123;&#10; &#10; case CHOOSE_PHOTO:&#10; if (resultCode == RESULT_OK)&#123;&#10; //&#21028;&#26029;&#25163;&#26426;&#31995;&#32479;&#29256;&#26412;&#21495;&#10; if (Build.VERSION.SDK_INT &#62;= 19)&#123;&#10; //4.4&#21450;&#20197;&#19978;&#30340;&#31995;&#32479;&#29992;&#36825;&#20010;&#26041;&#27861;&#22788;&#29702;&#22270;&#29255;&#10; handleImageOnKitKat(data);&#10; &#125; else &#123;&#10; //4.4&#20197;&#19979;&#30340;&#31995;&#32479;&#30340;&#29992;&#36825;&#20010;&#26041;&#27861;&#22788;&#29702;&#22270;&#29255;&#10; handleImageBeforeKitKat(data);&#10; &#125;&#10; &#125;&#10; break;&#10; default:&#10; break;&#10; &#125;&#10; &#125; 分别对Android4.4以上及以下的设备进行操作1@TargetApi(19)&#10; private void handleImageOnKitKat(Intent data) &#123;&#10; String imagePath = null;&#10; Uri uri = data.getData();&#10; Log.d(TAG, &#34;handleImageOnKitKat: uri :&#34; + uri);&#10; if (DocumentsContract.isDocumentUri(this,uri))&#123;&#10; //&#22914;&#26524;&#26159;document&#31867;&#22411;&#30340;Uri,&#21017;&#36890;&#36807;document id&#22788;&#29702;&#10; String docId = DocumentsContract.getDocumentId(uri);&#10;&#10; Log.d(TAG, &#34;handleImageOnKitKat: &#23553;&#35013;&#30340;docID : &#34; + docId);&#10; if (&#34;com.android.providers.media.documents&#34;.equals(uri.getAuthority()))&#123;&#10; //&#35299;&#26512;&#20986;&#25968;&#23383;&#26684;&#24335;&#30340;id&#10; String id = docId.split(&#34;:&#34;)[1];&#10; String selection = MediaStore.Images.Media._ID + &#34;=&#34; + id;&#10; Log.d(TAG, &#34;handleImageOnKitKat: selection ;&#34;+selection);&#10; imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI ,selection);&#10; &#125; else if (&#34;com.android.providers.downloads.documents&#34;.equals(uri.getAuthority()))&#123;&#10; Uri contentUri = ContentUris.withAppendedId(Uri.parse(&#34;content://downloads/public_downloads&#34;), Long.valueOf(docId));&#10; imagePath = uri.getPath();&#10; &#125;&#10;&#10; &#125; else if (&#34;content&#34;.equalsIgnoreCase(uri.getScheme()))&#123;&#10; //&#22914;&#26524;&#26159;content&#31867;&#22411;&#30340;uri,&#21017;&#20351;&#29992;&#26222;&#36890;&#26041;&#24335;&#22788;&#29702;&#10; imagePath = getImagePath(uri, null);&#10; &#125; else if (&#34;file&#34;.equalsIgnoreCase(uri.getScheme()))&#123;&#10; //&#22914;&#26524;&#26159;file&#31867;&#22411;&#30340;Uri,&#30452;&#25509;&#33719;&#21462;&#22270;&#29255;&#36335;&#24452;&#21363;&#21487;&#10; imagePath = uri.getPath();&#10; &#125;&#10; //&#26681;&#25454;&#36335;&#24452;&#26174;&#31034;&#22270;&#29255;&#10; displayImage(imagePath);&#10; &#125;&#10;&#10;&#10;&#10;&#10; private void handleImageBeforeKitKat(Intent data) &#123;&#10; Uri uri = data.getData();&#10; String imagePath = getImagePath(uri,null);&#10; displayImage(imagePath);&#10; &#125;&#10;&#10;&#10; //&#22788;&#29702;Uri&#65292;&#24471;&#21040;&#30495;&#23454;&#36335;&#24452;&#10; private String getImagePath(Uri uri, String selection) &#123;&#10; String path = null;&#10; //&#36890;&#36807;Uri &#21644; selection&#26469;&#33719;&#21462;&#30495;&#23454;&#30340;&#22270;&#29255;&#36335;&#24452;&#10; Cursor cursor = getContentResolver().query(uri, null,selection , null , null);&#10; if (cursor != null)&#123;&#10; if (cursor.moveToFirst())&#123;&#10; path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA));&#10; &#125;&#10; cursor.close();&#10; &#125;&#10; return path;&#10; &#125;&#10;&#10; private void displayImage(String imagePath) &#123;&#10; if (imagePath != null)&#123;&#10; Bitmap bitmap = BitmapFactory.decodeFile(imagePath);&#10; picture.setImageBitmap(bitmap);&#10; &#125; else &#123;&#10; Toast.makeText(this, &#34;failed to get image&#34;, Toast.LENGTH_SHORT).show();&#10; &#125;&#10; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://liuzhe6.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://liuzhe6.github.io/tags/Android/"}]},{"title":"Android将数据存储到文件中","slug":"Android将数据存储到文件中","date":"2017-01-19T02:27:48.000Z","updated":"2017-01-30T03:30:34.095Z","comments":true,"path":"2017/01/19/Android将数据存储到文件中/","link":"","permalink":"http://liuzhe6.github.io/2017/01/19/Android将数据存储到文件中/","excerpt":"","text":"Android开发中存储文件文件默认存储位置为 /data/data//files/目录下的主要有两种模式可选，MODE_PRIVATE和MODE_APPEND。MODE_PRIVATE：是默认操作模式，表示当指定同样文件名的时候，所写的内容会覆盖原文件中的内容。MODE_APPEND：表示如果该文件已经存在，就往文件里面追加内容，不存在就创建新文件。 下面是一段简单的代码示例：1public void save()&#123;&#10; String data = &#34;Data to save&#34;;&#10; FileOutputStream out = null;&#10; BufferedWriter writer = null;&#10; try&#123;&#10; out = openFileOutput(&#34;data&#34;, Context.MODE_PRIVATE);&#10; writer = new BufferedWriter(new OutputStreamWriter(out));&#10; writer.write(data);&#10; &#125; catch (IOException e)&#123;&#10; e.printStackTrace();&#10; &#125; finally &#123;&#10; try&#123;&#10; if (writer != null)&#123;&#10; writer.close();&#10; &#125;&#10; &#125; catch (IOException e) &#123;&#10; e.printStackTrace();&#10; &#125;&#10; &#125;&#10;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://liuzhe6.github.io/tags/Android/"},{"name":"数据存储","slug":"数据存储","permalink":"http://liuzhe6.github.io/tags/数据存储/"}]},{"title":"XML简介","slug":"XML简介","date":"2017-01-18T11:41:04.000Z","updated":"2017-01-19T02:29:02.518Z","comments":true,"path":"2017/01/18/XML简介/","link":"","permalink":"http://liuzhe6.github.io/2017/01/18/XML简介/","excerpt":"","text":"XML简介什么是XML可扩展标记语言是一种很像超文本标记语言的标记语言。它的设计宗旨是传输数据，而不是显示数据。它的标签没有被预定义。您需要自行定义标签。它被设计为具有自我描述性。它是W3C的推荐标准。 XML 树结构XML 文档形成了一种树结构，它从“根部”开始，然后扩展到“枝叶”。一个 XML 文档实例XML 使用简单的具有自我描述性的语法：第一行是 XML 声明。它定义 XML 的版本 (1.0) 和所使用的编码 (ISO-8859-1 = Latin-1/西欧字符集)。下一行描述文档的根元素（像在说：“本文档是一个便签”）：&lt;note&gt; 接下来 4 行描述根的 4 个子元素（to, from, heading 以及 body）：1to&#62;George&#60;/to&#62;&#10;&#60;from&#62;John&#60;/from&#62;&#10;&#60;heading&#62;Reminder&#60;/heading&#62;&#10;&#60;body&#62;Don&#39;t forget the meeting!&#60;/body&#62; 最后一行定义根元素的结尾：&lt;/note&gt; 从本例可以设想，该 XML 文档包含了 John 给 George 的一张便签。 XML 文档形成一种树结构XML 文档必须包含根元素。该元素是所有其他元素的父元素。XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。所有元素均可拥有子元素：1&#60;root&#62;&#10; &#60;child&#62;&#10; &#60;subchild&#62;.....&#60;/subchild&#62;&#10; &#60;/child&#62;&#10;&#60;/root&#62; 父、子以及同胞等术语用于描述元素之间的关系。父元素拥有子元素。相同层级上的子元素成为同胞（兄弟或姐妹）。所有元素均可拥有文本内容和属性（类似 HTML 中）。 实例 上图表示下面的 XML 中的一本书：1&#60;bookstore&#62;&#10;&#60;book category=&#34;COOKING&#34;&#62;&#10; &#60;title lang=&#34;en&#34;&#62;Everyday Italian&#60;/title&#62; &#10; &#60;author&#62;Giada De Laurentiis&#60;/author&#62; &#10; &#60;year&#62;2005&#60;/year&#62; &#10; &#60;price&#62;30.00&#60;/price&#62; &#10;&#60;/book&#62;&#10;&#60;book category=&#34;CHILDREN&#34;&#62;&#10; &#60;title lang=&#34;en&#34;&#62;Harry Potter&#60;/title&#62; &#10; &#60;author&#62;J K. Rowling&#60;/author&#62; &#10; &#60;year&#62;2005&#60;/year&#62; &#10; &#60;price&#62;29.99&#60;/price&#62; &#10;&#60;/book&#62;&#10;&#60;book category=&#34;WEB&#34;&#62;&#10; &#60;title lang=&#34;en&#34;&#62;Learning XML&#60;/title&#62; &#10; &#60;author&#62;Erik T. Ray&#60;/author&#62; &#10; &#60;year&#62;2003&#60;/year&#62; &#10; &#60;price&#62;39.95&#60;/price&#62; &#10;&#60;/book&#62;&#10;&#60;/bookstore&#62; 例子中的根元素是 。文档中的所有 元素都被包含在 中。 元素有 4 个子元素：、&lt; author&gt;、、。 XML 语法规则XML 的语法规则很简单，且很有逻辑。这些规则很容易学习，也很容易使用。所有 XML 元素都须有关闭标签在 HTML，经常会看到没有关闭标签的元素：1&#60;p&#62;This is a paragraph&#10;&#60;p&#62;This is another paragraph 在 XML 中，省略关闭标签是非法的。所有元素都必须有关闭标签：1&#60;p&#62;This is a paragraph&#60;/p&#62;&#10;&#60;p&#62;This is another paragraph&#60;/p&#62; XML 标签对大小写敏感XML 元素使用 XML 标签进行定义。XML 标签对大小写敏感。在 XML 中，标签 与标签 是不同的。必须使用相同的大小写来编写打开标签和关闭标签：1&#60;Message&#62;&#36825;&#26159;&#38169;&#35823;&#30340;&#12290;&#60;/message&#62;&#10;&#10;&#60;message&#62;&#36825;&#26159;&#27491;&#30830;&#30340;&#12290;&#60;/message&#62; XML 必须正确地嵌套在 HTML 中，常会看到没有正确嵌套的元素：&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt;在 XML 中，所有元素都必须彼此正确地嵌套：&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;在上例中，正确嵌套的意思是：由于 元素是在 元素内打开的，那么它必须在 元素内关闭。 XML 文档必须有根元素XML 文档必须有一个元素是所有其他元素的父元素。该元素称为根元素。1&#60;root&#62;&#10; &#60;child&#62;&#10; &#60;subchild&#62;.....&#60;/subchild&#62;&#10; &#60;/child&#62;&#10;&#60;/root&#62; XML 的属性值须加引号与 HTML 类似，XML 也可拥有属性（名称/值的对）。在 XML 中，XML 的属性值须加引号。请研究下面的两个 XML 文档。第一个是错误的，第二个是正确的：1&#60;note date=08/08/2008&#62;&#10;&#60;to&#62;George&#60;/to&#62;&#10;&#60;from&#62;John&#60;/from&#62;&#10;&#60;/note&#62; &#10;&#60;note date=&#34;08/08/2008&#34;&#62;&#10;&#60;to&#62;George&#60;/to&#62;&#10;&#60;from&#62;John&#60;/from&#62;&#10;&#60;/note&#62; 在第一个文档中的错误是，note 元素中的 date 属性没有加引号。 实体引用在 XML 中，一些字符拥有特殊的意义。如果你把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。这样会产生 XML 错误：&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;为了避免这个错误，请用实体引用来代替 “&lt;” 字符：&lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt;在 XML 中，有 5 个预定义的实体引用： 注释：在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。 XML 中的注释在 XML 中编写注释的语法与 HTML 的语法很相似：&lt;!-- This is a comment --&gt; 在 XML 中，空格会被保留HTML 会把多个连续的空格字符裁减（合并）为一个：1HTML:&#9;Hello my name is David.&#10;&#36755;&#20986;:&#9;Hello my name is David. 在 XML 中，文档中的空格不会被删节。 XML元素XML 文档包含 XML 元素。什么是 XML 元素？XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。元素可包含其他元素、文本或者两者的混合物。元素也可以拥有属性。1&#60;bookstore&#62;&#10;&#60;book category=&#34;CHILDREN&#34;&#62;&#10; &#60;title&#62;Harry Potter&#60;/title&#62; &#10; &#60;author&#62;J K. Rowling&#60;/author&#62; &#10; &#60;year&#62;2005&#60;/year&#62; &#10; &#60;price&#62;29.99&#60;/price&#62; &#10;&#60;/book&#62;&#10;&#60;book category=&#34;WEB&#34;&#62;&#10; &#60;title&#62;Learning XML&#60;/title&#62; &#10; &#60;author&#62;Erik T. Ray&#60;/author&#62; &#10; &#60;year&#62;2003&#60;/year&#62; &#10; &#60;price&#62;39.95&#60;/price&#62; &#10;&#60;/book&#62;&#10;&#60;/bookstore&#62; 在上例中， 和 都拥有元素内容，因为它们包含了其他元素。 只有文本内容，因为它仅包含文本。在上例中，只有 元素拥有属性 (category=”CHILDREN”)。 XML 命名规则XML 元素必须遵循以下命名规则： 名称可以含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字符 “xml”（或者 XML、Xml）开始 名称不能包含空格 可使用任何名称，没有保留的字词。 最佳命名习惯使名称具有描述性。使用下划线的名称也很不错。名称应当比较简短，比如：，而不是：。避免 “-“ 字符。如果您按照这样的方式进行命名：”first-name”，一些软件会认为你需要提取第一个单词。避免 “.” 字符。如果您按照这样的方式进行命名：”first.name”，一些软件会认为 “name” 是对象 “first” 的属性。避免 “:” 字符。冒号会被转换为命名空间来使用（稍后介绍）。XML 文档经常有一个对应的数据库，其中的字段会对应 XML 文档中的元素。有一个实用的经验，即使用数据库的名称规则来命名 XML 文档中的元素。非英语的字母比如 éòá 也是合法的 XML 元素名，不过需要留意当软件开发商不支持这些字符时可能出现的问题。 XML 元素是可扩展的XML 元素是可扩展，以携带更多的信息。请看下面这个 XML 例子：1&#60;note&#62;&#10;&#60;to&#62;George&#60;/to&#62;&#10;&#60;from&#62;John&#60;/from&#62;&#10;&#60;body&#62;Don&#39;t forget the meeting!&#60;/body&#62;&#10;&#60;/note&#62; 让我们设想一下，我们创建了一个应用程序，可将 、 以及 元素提取出来，并产生以下的输出：1MESSAGE&#10;To: George&#10;From: John&#10;&#10;Don&#39;t forget the meeting! 想象一下，之后这个 XML 文档作者又向这个文档添加了一些额外的信息：1&#60;note&#62;&#10;&#60;date&#62;2008-08-08&#60;/date&#62;&#10;&#60;to&#62;George&#60;/to&#62;&#10;&#60;from&#62;John&#60;/from&#62;&#10;&#60;heading&#62;Reminder&#60;/heading&#62;&#10;&#60;body&#62;Don&#39;t forget the meeting!&#60;/body&#62;&#10;&#60;/note&#62; 那么这个应用程序会中断或崩溃吗？不会。这个应用程序仍然可以找到 XML 文档中的 、 以及 元素，并产生同样的输出。XML 的优势之一，就是可以经常在不中断应用程序的情况进行扩展。 XML 属性XML 元素可以在开始标签中包含属性，类似 HTML。属性 (Attribute) 提供关于元素的额外（附加）信息。 XML 属性从 HTML，你会回忆起这个：&lt;img src=&quot;computer.gif&quot;&gt;。”src” 属性提供有关 元素的额外信息。在 HTML 中（以及在 XML 中），属性提供有关元素的额外信息：1&#60;img src=&#34;computer.gif&#34;&#62;&#10;&#60;a href=&#34;demo.asp&#34;&#62; 属性通常提供不属于数据组成部分的信息。在下面的例子中，文件类型与数据无关，但是对需要处理这个元素的软件来说却很重要：&lt;file type=&quot;gif&quot;&gt;computer.gif&lt;/file&gt; XML 属性必须加引号属性值必须被引号包围，不过单引号和双引号均可使用。比如一个人的性别，person 标签可以这样写：&lt;person sex=&quot;female&quot;&gt;或者这样也可以：&lt;person sex=&#39;female&#39;&gt;注释：如果属性值本身包含双引号，那么有必要使用单引号包围它，就像这个例子：&lt;gangster name=&#39;George &quot;Shotgun&quot; Ziegler&#39;&gt;或者可以使用实体引用：&lt;gangster name=&quot;George &amp;quot;Shotgun&amp;quot; Ziegler&quot;&gt; XML 元素 vs. 属性请看这些例子：1&#60;person sex=&#34;female&#34;&#62;&#10; &#60;firstname&#62;Anna&#60;/firstname&#62;&#10; &#60;lastname&#62;Smith&#60;/lastname&#62;&#10;&#60;/person&#62; &#10;&#10;&#60;person&#62;&#10; &#60;sex&#62;female&#60;/sex&#62;&#10; &#60;firstname&#62;Anna&#60;/firstname&#62;&#10; &#60;lastname&#62;Smith&#60;/lastname&#62;&#10;&#60;/person&#62; 在第一个例子中，sex 是一个属性。在第二个例子中，sex 则是一个子元素。两个例子均可提供相同的信息。没有什么规矩可以告诉我们什么时候该使用属性，而什么时候该使用子元素。我的经验是在 HTML 中，属性用起来很便利，但是在 XML 中，您应该尽量避免使用属性。如果信息感觉起来很像数据，那么请使用子元素吧。 我最喜欢的方式下面的三个 XML 文档包含完全相同的信息：第一个例子中使用了 date 属性：1&#60;note date=&#34;08/08/2008&#34;&#62;&#10;&#60;to&#62;George&#60;/to&#62;&#10;&#60;from&#62;John&#60;/from&#62;&#10;&#60;heading&#62;Reminder&#60;/heading&#62;&#10;&#60;body&#62;Don&#39;t forget the meeting!&#60;/body&#62;&#10;&#60;/note&#62; 第二个例子中使用了 date 元素：1&#60;note&#62;&#10;&#60;date&#62;08/08/2008&#60;/date&#62;&#10;&#60;to&#62;George&#60;/to&#62;&#10;&#60;from&#62;John&#60;/from&#62;&#10;&#60;heading&#62;Reminder&#60;/heading&#62;&#10;&#60;body&#62;Don&#39;t forget the meeting!&#60;/body&#62;&#10;&#60;/note&#62; 第三个例子中使用了扩展的 date 元素（这是我的最爱）：1&#60;note&#62;&#10;&#60;date&#62;&#10; &#60;day&#62;08&#60;/day&#62;&#10; &#60;month&#62;08&#60;/month&#62;&#10; &#60;year&#62;2008&#60;/year&#62;&#10;&#60;/date&#62;&#10;&#60;to&#62;George&#60;/to&#62;&#10;&#60;from&#62;John&#60;/from&#62;&#10;&#60;heading&#62;Reminder&#60;/heading&#62;&#10;&#60;body&#62;Don&#39;t forget the meeting!&#60;/body&#62;&#10;&#60;/note&#62; 以上内容摘自 http://www.w3school.com.cn/xml/index.asp","categories":[],"tags":[{"name":"XML","slug":"XML","permalink":"http://liuzhe6.github.io/tags/XML/"}]},{"title":"jstl简介","slug":"jstl简介","date":"2017-01-18T11:16:30.000Z","updated":"2017-01-18T11:30:16.063Z","comments":true,"path":"2017/01/18/jstl简介/","link":"","permalink":"http://liuzhe6.github.io/2017/01/18/jstl简介/","excerpt":"","text":"JSP标准标签库JSTL核心标签核心标签是最常用的JSTL标签。引用核心标签库的语法如下：1&#60;%@ taglib prefix=&#34;c&#34; &#10; uri=&#34;http://java.sun.com/jsp/jstl/core&#34; %&#62; logo 格式化标签JSTL格式化标签用来格式化并输出文本、日期、时间、数字。引用格式化标签库的语法如下：1&#60;%@ taglib prefix=&#34;fmt&#34; &#10; uri=&#34;http://java.sun.com/jsp/jstl/fmt&#34; %&#62; logo SQL标签JSTL SQL标签库提供了与关系型数据库（Oracle，MySQL，SQL Server等等）进行交互的标签。引用SQL标签库的语法如下：1&#60;%@ taglib prefix=&#34;sql&#34; &#10; uri=&#34;http://java.sun.com/jsp/jstl/sql&#34; %&#62; logo XML标签1&#60;%@ taglib prefix=&#34;x&#34; &#10; uri=&#34;http://java.sun.com/jsp/jstl/xml&#34; %&#62; 在使用xml标签前，你必须将XML 和 XPath 的相关包拷贝至你的\\lib下: XercesImpl.jar下载地址： http://www.apache.org/dist/xerces/j/ xalan.jar下载地址： http://xml.apache.org/xalan-j/index.html JSTL函数JSTL包含一系列标准函数，大部分是通用的字符串处理函数。引用JSTL函数库的语法如下：1&#60;%@ taglib prefix=&#34;fn&#34; &#10; uri=&#34;http://java.sun.com/jsp/jstl/functions&#34; %&#62; logo 以上内容摘自 http://www.runoob.com/jsp/jsp-jstl.html","categories":[],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://liuzhe6.github.io/tags/jsp/"},{"name":"jstl","slug":"jstl","permalink":"http://liuzhe6.github.io/tags/jstl/"}]},{"title":"jQuery ajax","slug":"jQuery-ajax","date":"2017-01-16T07:55:18.000Z","updated":"2017-01-30T04:27:59.734Z","comments":true,"path":"2017/01/16/jQuery-ajax/","link":"","permalink":"http://liuzhe6.github.io/2017/01/16/jQuery-ajax/","excerpt":"","text":"jQuery ajax实例通过 AJAX 加载一段文本：jQuery 代码：1$(document).ready(function()&#123;&#10; $(&#34;#b01&#34;).click(function()&#123;&#10; htmlobj=$.ajax(&#123;url:&#34;/jquery/test1.txt&#34;,async:false&#125;);&#10; $(&#34;#myDiv&#34;).html(htmlobj.responseText);&#10; &#125;);&#10;&#125;); HTML 代码：1&#60;div id=&#34;myDiv&#34;&#62;&#60;h2&#62;Let AJAX change this text&#60;/h2&#62;&#60;/div&#62;&#10;&#60;button id=&#34;b01&#34; type=&#34;button&#34;&#62;Change Content&#60;/button&#62; 定义和用法ajax() 方法通过 HTTP 请求加载远程数据。该方法是 jQuery 底层 AJAX 实现。简单易用的高层实现见 $.get, $.post 等。$.ajax() 返回其创建的 XMLHttpRequest 对象。大多数情况下你无需直接操作该函数，除非你需要操作不常用的选项，以获得更多的灵活性。最简单的情况下，$.ajax() 可以不带任何参数直接使用。注意：所有的选项都可以通过 $.ajaxSetup() 函数来全局设置。语法1jQuery.ajax([settings]) logo 参数options类型：Object可选。AJAX 请求设置。所有选项都是可选的。 async类型：Boolean默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。 beforeSend(XHR)类型：Function发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头。XMLHttpRequest 对象是唯一的参数。这是一个 Ajax 事件。如果返回 false 可以取消本次 ajax 请求。 cache类型：Boolean默认值: true，dataType 为 script 和 jsonp 时默认为 false。设置为 false 将不缓存此页面。jQuery 1.2 新功能。 complete(XHR, TS)类型：Function请求完成后回调函数 (请求成功或失败之后均调用)。参数： XMLHttpRequest 对象和一个描述请求类型的字符串。这是一个 Ajax 事件。 contentType类型：String默认值: “application/x-www-form-urlencoded”。发送信息至服务器时内容编码类型。默认值适合大多数情况。如果你明确地传递了一个 content-type 给 $.ajax() 那么它必定会发送给服务器（即使没有数据要发送）。 context类型：Object这个对象用于设置 Ajax 相关回调函数的上下文。也就是说，让回调函数内 this 指向这个对象（如果不设定这个参数，那么 this 就指向调用本次 AJAX 请求时传递的 options 参数）。比如指定一个 DOM 元素作为 context 参数，这样就设置了 success 回调函数的上下文为这个 DOM 元素。就像这样：1$.ajax(&#123; url: &#34;test.html&#34;, context: document.body, success: function()&#123;&#10; $(this).addClass(&#34;done&#34;);&#10; &#125;&#125;); data类型：String发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[“bar1”, “bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。 dataFilter类型：Function给 Ajax 返回的原始数据的进行预处理的函数。提供 data 和 type 两个参数：data 是 Ajax 返回的原始数据，type 是调用 jQuery.ajax 时提供的 dataType 参数。函数返回的值将由 jQuery 进一步处理。 dataType类型：String预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断，比如 XML MIME 类型就被识别为 XML。在 1.4 中，JSON 就会生成一个 JavaScript 对象，而 script 则会执行这个脚本。随后服务器端返回的数据会根据这个值解析后，传递给回调函数。可用值:“xml”: 返回 XML 文档，可用 jQuery 处理。“html”: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。“script”: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 “cache” 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载）“json”: 返回 JSON 数据 。“jsonp”: JSONP 格式。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。“text”: 返回纯文本字符串 error类型：Function默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是 “timeout”, “error”, “notmodified” 和 “parsererror”。这是一个 Ajax 事件。 global类型：Boolean是否触发全局 AJAX 事件。默认值: true。设置为 false 将不会触发全局 AJAX 事件，如 ajaxStart 或 ajaxStop 可用于控制不同的 Ajax 事件。 ifModified类型：Boolean仅在服务器数据改变时获取新数据。默认值: false。使用 HTTP 包 Last-Modified 头信息判断。在 jQuery 1.4 中，它也会检查服务器指定的 ‘etag’ 来确定数据没有被修改过。 jsonp类型：String在一个 jsonp 请求中重写回调函数的名字。这个值用来替代在 “callback=?” 这种 GET 或 POST 请求中 URL 参数里的 “callback” 部分，比如 {jsonp:’onJsonPLoad’} 会导致将 “onJsonPLoad=?” 传给服务器。 jsonpCallback类型：String为 jsonp 请求指定一个回调函数名。这个值将用来取代 jQuery 自动生成的随机函数名。这主要用来让 jQuery 生成度独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。你也可以在想让浏览器缓存 GET 请求的时候，指定这个回调函数名。 password类型：String用于响应 HTTP 访问认证请求的密码processData类型：Boolean默认值: true。默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。 scriptCharset类型：String只有当请求时 dataType 为 “jsonp” 或 “script”，并且 type 是 “GET” 才会用于强制修改 charset。通常只在本地和远程的内容编码不同时使用。 success类型：Function请求成功后的回调函数。参数：由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串。这是一个 Ajax 事件。 traditional类型：Boolean如果你想要用传统的方式来序列化数据，那么就设置为 true。请参考工具分类下面的 jQuery.param 方法。 timeout类型：Number设置请求超时时间（毫秒）。此设置将覆盖全局设置。 type类型：String默认值: “GET”)。请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。 url类型：String默认值: 当前页地址。发送请求的地址。 username类型：String用于响应 HTTP 访问认证请求的用户名。 xhr类型：Function需要返回一个 XMLHttpRequest 对象。默认在 IE 下是 ActiveXObject 而其他情况下是 XMLHttpRequest 。用于重写或者提供一个增强的 XMLHttpRequest 对象。这个参数在 jQuery 1.3 以前不可用。 回调函数如果要处理 $.ajax() 得到的数据，则需要使用回调函数：beforeSend、error、dataFilter、success、complete。 beforeSend在发送请求之前调用，并且传入一个 XMLHttpRequest 作为参数。 error在请求出错时调用。传入 XMLHttpReques 对象，描述错误类型的字符串以及一个异常对象（如果有的话） dataFilter在请求成功之后调用。传入返回的数据以及 “dataType” 参数的值。并且必须返回新的数据（可能是处理过的）传递给 success 回调函数。 success当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。 complete当请求完成之后调用这个函数，无论成功或失败。传入 XMLHttpRequest 对象，以及一个包含成功或错误代码的字符串。 数据类型$.ajax() 函数依赖服务器提供的信息来处理返回的数据。如果服务器报告说返回的数据是 XML，那么返回的结果就可以用普通的 XML 方法或者 jQuery 的选择器来遍历。如果见得到其他类型，比如 HTML，则数据就以文本形式来对待。通过 dataType 选项还可以指定其他不同数据处理方式。除了单纯的 XML，还可以指定 html、json、jsonp、script 或者 text。其中，text 和 xml 类型返回的数据不会经过处理。数据仅仅简单的将 XMLHttpRequest 的 responseText 或 responseHTML 属性传递给 success 回调函数。 注意：我们必须确保网页服务器报告的 MIME 类型与我们选择的 dataType 所匹配。比如说，XML的话，服务器端就必须声明 text/xml 或者 application/xml 来获得一致的结果。如果指定为 html 类型，任何内嵌的 JavaScript 都会在 HTML 作为一个字符串返回之前执行。类似地，指定 script 类型的话，也会先执行服务器端生成 JavaScript，然后再把脚本作为一个文本数据返回。 如果指定为 json 类型，则会把获取到的数据作为一个 JavaScript 对象来解析，并且把构建好的对象作为结果返回。为了实现这个目的，它首先尝试使用 JSON.parse()。如果浏览器不支持，则使用一个函数来构建。 JSON 数据是一种能很方便通过 JavaScript 解析的结构化数据。如果获取的数据文件存放在远程服务器上（域名不同，也就是跨域获取数据），则需要使用 jsonp 类型。使用这种类型的话，会创建一个查询字符串参数 callback=? ，这个参数会加在请求的 URL 后面。服务器端应当在 JSON 数据前加上回调函数名，以便完成一个有效的 JSONP 请求。如果要指定回调函数的参数名来取代默认的 callback，可以通过设置 $.ajax() 的 jsonp 参数。 注意：JSONP 是 JSON 格式的扩展。它要求一些服务器端的代码来检测并处理查询字符串参数。如果指定了 script 或者 jsonp 类型，那么当从服务器接收到数据时，实际上是用了 标签而不是 XMLHttpRequest 对象。这种情况下，$.ajax() 不再返回一个 XMLHttpRequest 对象，并且也不会传递事件处理函数，比如 beforeSend。 发送数据到服务器默认情况下，Ajax 请求使用 GET 方法。如果要使用 POST 方法，可以设定 type 参数值。这个选项也会影响 data 选项中的内容如何发送到服务器。 data 选项既可以包含一个查询字符串，比如 key1=value1&amp;key2=value2 ，也可以是一个映射，比如 {key1: ‘value1’, key2: ‘value2’} 。如果使用了后者的形式，则数据再发送器会被转换成查询字符串。这个处理过程也可以通过设置 processData 选项为 false 来回避。如果我们希望发送一个 XML 对象给服务器时，这种处理可能并不合适。并且在这种情况下，我们也应当改变 contentType 选项的值，用其他合适的 MIME 类型来取代默认的 application/x-www-form-urlencoded 。 高级选项global 选项用于阻止响应注册的回调函数，比如 .ajaxSend，或者 ajaxError，以及类似的方法。这在有些时候很有用，比如发送的请求非常频繁且简短的时候，就可以在 ajaxSend 里禁用这个。 如果服务器需要 HTTP 认证，可以使用用户名和密码可以通过 username 和 password 选项来设置。 Ajax 请求是限时的，所以错误警告被捕获并处理后，可以用来提升用户体验。请求超时这个参数通常就保留其默认值，要不就通过 jQuery.ajaxSetup 来全局设定，很少为特定的请求重新设置 timeout 选项。 默认情况下，请求总会被发出去，但浏览器有可能从它的缓存中调取数据。要禁止使用缓存的结果，可以设置 cache 参数为 false。如果希望判断数据自从上次请求后没有更改过就报告出错的话，可以设置 ifModified 为 true。 scriptCharset 允许给 标签的请求设定一个特定的字符集，用于 script 或者 jsonp 类似的数据。当脚本和页面字符集不同时，这特别好用。 Ajax 的第一个字母是 asynchronous 的开头字母，这意味着所有的操作都是并行的，完成的顺序没有前后关系。$.ajax() 的 async 参数总是设置成true，这标志着在请求开始后，其他代码依然能够执行。强烈不建议把这个选项设置成 false，这意味着所有的请求都不再是异步的了，这也会导致浏览器被锁死。 $.ajax 函数返回它创建的 XMLHttpRequest 对象。通常 jQuery 只在内部处理并创建这个对象，但用户也可以通过 xhr 选项来传递一个自己创建的 xhr 对象。返回的对象通常已经被丢弃了，但依然提供一个底层接口来观察和操控请求。比如说，调用对象上的 .abort() 可以在请求完成前挂起请求。 以上内容全部摘自 WSchool","categories":[],"tags":[{"name":"ajax","slug":"ajax","permalink":"http://liuzhe6.github.io/tags/ajax/"},{"name":"jQuery","slug":"jQuery","permalink":"http://liuzhe6.github.io/tags/jQuery/"}]},{"title":"Ajax简介","slug":"Ajax简介","date":"2017-01-16T03:22:53.000Z","updated":"2017-01-18T10:44:42.663Z","comments":true,"path":"2017/01/16/Ajax简介/","link":"","permalink":"http://liuzhe6.github.io/2017/01/16/Ajax简介/","excerpt":"","text":"ajax开发AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。AJAX = 异步 JavaScript和XML（标准通用标记语言的子集）。AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个网页页面。 摘自百度百科 AJAX - 创建 XMLHttpRequest 对象XMLHttpRequest 是 AJAX 的基础。XMLHttpRequest 对象所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。创建 XMLHttpRequest 对象所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。创建 XMLHttpRequest 对象的语法：1variable=new XMLHttpRequest(); 老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：1variable=new ActiveXObject(&#34;Microsoft.XMLHTTP&#34;); 为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：1var xmlhttp; &#10;if (window.XMLHttpRequest)&#10; &#123;// code for IE7+, Firefox, Chrome, Opera, Safari&#10; xmlhttp=new XMLHttpRequest();&#10; &#125;&#10;else&#10; &#123;// code for IE6, IE5&#10; xmlhttp=new ActiveXObject(&#34;Microsoft.XMLHTTP&#34;);&#10; &#125; AJAX - 向服务器发送请求XMLHttpRequest 对象用于和服务器交换数据。向服务器发送请求如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：1xmlhttp.open(&#34;GET&#34;,&#34;test1.txt&#34;,true);&#10;xmlhttp.send(); logo GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 GET 请求一个简单的 GET 请求：1xmlhttp.open(&#34;GET&#34;,&#34;demo_get.asp&#34;,true);&#10;xmlhttp.send(); 在上面的例子中，您可能得到的是缓存的结果。为了避免这种情况，请向 URL 添加一个唯一的 ID：1xmlhttp.open(&#34;GET&#34;,&#34;demo_get.asp?t=&#34; + Math.random(),true);&#10;xmlhttp.send(); 如果您希望通过 GET 方法发送信息，请向 URL 添加信息：1xmlhttp.open(&#34;GET&#34;,&#34;demo_get2.asp?fname=Bill&#38;lname=Gates&#34;,true);&#10;xmlhttp.send(); POST 请求一个简单 POST 请求：1xmlhttp.open(&#34;POST&#34;,&#34;demo_post.asp&#34;,true);&#10;xmlhttp.send(); 如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据：1xmlhttp.open(&#34;POST&#34;,&#34;ajax_test.asp&#34;,true);&#10;xmlhttp.setRequestHeader(&#34;Content-type&#34;,&#34;application/x-www-form-urlencoded&#34;);&#10;xmlhttp.send(&#34;fname=Bill&#38;lname=Gates&#34;); logo url - 服务器上的文件open() 方法的 url 参数是服务器上文件的地址：xmlhttp.open(&quot;GET&quot;,&quot;ajax_test.asp&quot;,true);该文件可以是任何类型的文件，比如 .txt 和 .xml，或者服务器脚本文件，比如 .asp 和 .php （在传回响应之前，能够在服务器上执行任务）。 异步 - True 或 False？AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true：xmlhttp.open(&quot;GET&quot;,&quot;ajax_test.asp&quot;,true);对于 web 开发人员来说，发送异步请求是一个巨大的进步。很多在服务器执行的任务都相当费时。AJAX 出现之前，这可能会引起应用程序挂起或停止。通过 AJAX，JavaScript 无需等待服务器的响应，而是： 在等待服务器响应时执行其他脚本 当响应就绪后对响应进行处理 Async = true当使用 async=true 时，请规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数：1xmlhttp.onreadystatechange=function()&#10; &#123;&#10; if (xmlhttp.readyState==4 &#38;&#38; xmlhttp.status==200)&#10; &#123;&#10; document.getElementById(&#34;myDiv&#34;).innerHTML=xmlhttp.responseText;&#10; &#125;&#10; &#125;&#10;xmlhttp.open(&#34;GET&#34;,&#34;test1.txt&#34;,true);&#10;xmlhttp.send(); Async = false如需使用 async=false，请将 open() 方法中的第三个参数改为 false：xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,false);我们不推荐使用 async=false，但是对于一些小型的请求，也是可以的。请记住，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。注释：当您使用 async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可：1xmlhttp.open(&#34;GET&#34;,&#34;test1.txt&#34;,false);&#10;xmlhttp.send();&#10;document.getElementById(&#34;myDiv&#34;).innerHTML=xmlhttp.responseText; AJAX - 服务器响应服务器响应如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 responseText 属性如果来自服务器的响应并非 XML，请使用 responseText 属性。responseText 属性返回字符串形式的响应，因此您可以这样使用：document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; responseXML 属性如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML 属性：请求 books.xml 文件，并解析响应： 1xmlDoc=xmlhttp.responseXML;&#10;txt=&#34;&#34;;&#10;x=xmlDoc.getElementsByTagName(&#34;ARTIST&#34;);&#10;for (i=0;i&#60;x.length;i++)&#10; &#123;&#10; txt=txt + x[i].childNodes[0].nodeValue + &#34;&#60;br /&#62;&#34;;&#10; &#125;&#10;document.getElementById(&#34;myDiv&#34;).innerHTML=txt; 以上内容来自 WSchool 点击","categories":[],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://liuzhe6.github.io/tags/Ajax/"}]},{"title":"idea建立web service client时抛出SAXParseException解决办法","slug":"idea建立web-service-client时抛出SAXParseException解决办法","date":"2017-01-14T03:05:03.000Z","updated":"2017-01-14T03:07:06.975Z","comments":true,"path":"2017/01/14/idea建立web-service-client时抛出SAXParseException解决办法/","link":"","permalink":"http://liuzhe6.github.io/2017/01/14/idea建立web-service-client时抛出SAXParseException解决办法/","excerpt":"","text":"使用idea开发平台建立web service client抛出异常问题描述:抛出java.lang.AssertionError: org.xml.sax.SAXParseException; systemId: jar.. 问题原因:我使用的jdk版本为jdk8,而jdk8对jaxb-xjc-2.2.7有这个BUG,详细原因请点击查看 解决方法:在 jdk1.8.0/jre/lib 下创建一个文件 jaxp.properties,并且在文件中写下一句话javax.xml.accessExternalSchema = all 从CSDN整理并发表","categories":[],"tags":[{"name":"idea","slug":"idea","permalink":"http://liuzhe6.github.io/tags/idea/"},{"name":"web service client","slug":"web-service-client","permalink":"http://liuzhe6.github.io/tags/web-service-client/"},{"name":"异常","slug":"异常","permalink":"http://liuzhe6.github.io/tags/异常/"}]},{"title":"json语法","slug":"json语法","date":"2017-01-06T13:37:30.000Z","updated":"2017-01-06T13:37:43.076Z","comments":true,"path":"2017/01/06/json语法/","link":"","permalink":"http://liuzhe6.github.io/2017/01/06/json语法/","excerpt":"","text":"json语法JSON 语法是 JavaScript 语法的子集。JSON 语法规则 JSON 语法是 JavaScript 对象表示法语法的子集。数据在名称/值对中数据由逗号分隔花括号保存对象方括号保存数组JSON 名称/值对 JSON 数据的书写格式是：名称/值对。名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：&quot;firstName&quot; : &quot;John&quot;这很容易理解，等价于这条 JavaScript 语句：firstName = &quot;John&quot;JSON 值 JSON 值可以是：数字（整数或浮点数）字符串（在双引号中）逻辑值（true 或 false）数组（在方括号中）对象（在花括号中）nullJSON 对象 JSON 对象在花括号中书写：对象可以包含多个名称/值对：{ &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; }这一点也容易理解，与这条 JavaScript 语句等价：firstName = &quot;John&quot;lastName = &quot;Doe&quot;JSON 数组 JSON 数组在方括号中书写：数组可包含多个对象：1&#123;&#10;&#34;employees&#34;: [&#10;&#123; &#34;firstName&#34;:&#34;John&#34; , &#34;lastName&#34;:&#34;Doe&#34; &#125;,&#10;&#123; &#34;firstName&#34;:&#34;Anna&#34; , &#34;lastName&#34;:&#34;Smith&#34; &#125;,&#10;&#123; &#34;firstName&#34;:&#34;Peter&#34; , &#34;lastName&#34;:&#34;Jones&#34; &#125;&#10;]&#10;&#125; 在上面的例子中，对象 “employees” 是包含三个对象的数组。每个对象代表一条关于某人（有姓和名）的记录。JSON 使用 JavaScript 语法 因为 JSON 使用 JavaScript 语法，所以无需额外的软件就能处理 JavaScript 中的 JSON。通过 JavaScript，您可以创建一个对象数组，并像这样进行赋值：例子1var employees = [&#10;&#123; &#34;firstName&#34;:&#34;Bill&#34; , &#34;lastName&#34;:&#34;Gates&#34; &#125;,&#10;&#123; &#34;firstName&#34;:&#34;George&#34; , &#34;lastName&#34;:&#34;Bush&#34; &#125;,&#10;&#123; &#34;firstName&#34;:&#34;Thomas&#34; , &#34;lastName&#34;: &#34;Carter&#34; &#125;&#10;]; 可以像这样访问 JavaScript 对象数组中的第一项：employees[0].lastName;返回的内容是：Gates可以像这样修改数据：employees[0].lastName = &quot;Jobs&quot;;","categories":[],"tags":[{"name":"json","slug":"json","permalink":"http://liuzhe6.github.io/tags/json/"}]},{"title":"一个jsp向另一个jsp传值","slug":"一个jsp向另一个jsp传值","date":"2017-01-06T13:31:42.000Z","updated":"2017-01-06T13:31:51.966Z","comments":true,"path":"2017/01/06/一个jsp向另一个jsp传值/","link":"","permalink":"http://liuzhe6.github.io/2017/01/06/一个jsp向另一个jsp传值/","excerpt":"","text":"一个jsp向另一个jsp传值 通过jsp的内置对象—request对象获取参数：（1）通过超链接传参：例：把a.jsp中i的值传到b.jsp中：在a.jsp页面中的核心代码为:传参 （说明：给i赋值时也可以用jsp表达式，例如i=&lt;%变量名 %&gt;)在b.jsp页面中的核心代码为： 1&#60;%String j=request.getParameter(&#34;i&#34;); %&#62;&#10;&#60;%=j %&#62; （2）通过request.setAttribute()方法：例：把a.jsp中表单中的name的值传送到b.jsp中： 在a.jsp页面中的核心代码为：&lt;%request.setAttribute(name,&quot;Danny&quot;);%&gt;在b.jsp页面中的核心代码为：&lt;%String getName=request.getParameter(&quot;name&quot;); %&gt; （3）通过表单传参：例：把a.jsp中表单中的name的值传送到b.jsp中：在a.jsp页面中的核心代码为： 重要的是，在jsp脚本中是无法使用EL表达式的，但是可以替换1&#60;%&#10; request.setAttribute(&#34;username&#34;, request.getAttribute(&#34;username&#34;));&#10; request.setAttribute(&#34;email&#34;, request.getAttribute(&#34;email&#34;));&#10;%&#62;","categories":[],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://liuzhe6.github.io/tags/jsp/"}]},{"title":"JavaScript","slug":"JavaScript","date":"2017-01-06T13:15:55.000Z","updated":"2017-01-06T13:22:45.692Z","comments":true,"path":"2017/01/06/JavaScript/","link":"","permalink":"http://liuzhe6.github.io/2017/01/06/JavaScript/","excerpt":"","text":"JavaScriptJavaScript简介JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。在1995年时，由Netscape公司的Brendan Eich，在网景导航者浏览器上首次设计实现而成。因为Netscape与Sun合作，Netscape管理层希望它外观看起来像Java，因此取名为JavaScript。但实际上它的语法风格与Self及Scheme较为接近。为了取得技术优势，微软推出了JScript，CEnvi推出ScriptEase，与JavaScript同样可在浏览器上运行。为了统一规格，因为JavaScript兼容于ECMA标准，因此也称为ECMAScript。 戳这里 W3School学习网站 JavaScript：写入 HTML 输出实例1document.write(&#34;&#60;h1&#62;This is a heading&#60;/h1&#62;&#34;);&#10;document.write(&#34;&#60;p&#62;This is a paragraph&#60;/p&#62;&#34;); 提示：您只能在 HTML 输出中使用 document.write。如果您在文档加载后使用该方法，会覆盖整个文档。 JavaScript：对事件作出反应&lt;button type=&quot;button&quot; onclick=&quot;alert(&#39;Welcome!&#39;)&quot;&gt;点击这里&lt;/button&gt;alert() 函数在 JavaScript 中并不常用，但它对于代码测试非常方便。onclick 事件只是您即将在本教程中学到的众多事件之一。 JavaScript：改变 HTML 内容使用 JavaScript 来处理 HTML 内容是非常强大的功能。1x=document.getElementById(&#34;demo&#34;) //&#26597;&#25214;&#20803;&#32032;&#10;x.innerHTML=&#34;Hello JavaScript&#34;; //&#25913;&#21464;&#20869;&#23481; 您会经常看到 document.getElementByID(“some id”)。这个方法是 HTML DOM 中定义的。DOM（文档对象模型）是用以访问 HTML 元素的正式 W3C 标准。您将在本教程的多个章节中学到有关 HTML DOM 的知识。 JavaScript 与 Java 是两种完全不同的语言，无论在概念还是设计上。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://liuzhe6.github.io/tags/JavaScript/"}]},{"title":"JSP","slug":"JSP","date":"2017-01-06T12:45:24.000Z","updated":"2017-01-06T13:10:53.117Z","comments":true,"path":"2017/01/06/JSP/","link":"","permalink":"http://liuzhe6.github.io/2017/01/06/JSP/","excerpt":"","text":"JSP简介什么是JSPJSP全名为Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servlet设计，它[1] 是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP技术有点类似ASP技术，它是在传统的网页HTML（标准通用标记语言的子集）文件(.htm,.html)中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。 用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。 它实现了Html语法中的java扩展（以 &lt;%, %&gt;形式）。JSP与Servlet一样，是在服务器端执行的。通常返回给客户端的就是一个HTML文本，因此客户端只要有浏览器就能浏览。 Java Servlet是JSP的技术基础，而且大型的Web应用程序的开发需要Java Servlet和JSP配合才能完成。JSP具备了Java技术的简单易用，完全的面向对象，具有平台无关性且安全可靠，主要面向因特网的所有特点。 (详细介绍请查阅相关资料 这里就不一一介绍了) 第一个JSP第一个JSP程序语言学习入门的第一个程序一般都是输出”Hello World！”，JSP输出”Hello World！”代码如下所示:1&#60;html&#62;&#10; &#60;head&#62;&#10; &#60;title&#62;&#31532;&#19968;&#20010;JSP&#31243;&#24207;&#60;/title&#62;&#10; &#60;/head&#62;&#10; &#60;body&#62;&#10; &#60;%&#10; out.println(&#34;Hello World&#65281;&#34;);&#10; %&#62;&#10; &#60;/body&#62;&#10;&#60;/html&#62; JSP语法脚本程序脚本程序可以包含任意量的Java语句、变量、方法或表达式，只要它们在脚本语言中是有效的。脚本程序的语法格式：&lt;% 代码片段 %&gt;或者，您也可以编写与其等价的XML语句，就像下面这样： 代码片段任何文本、HTML标签、JSP元素必须写在脚本程序的外面。下面给出一个示例，同时也是本教程的第一个JSP示例：1&#60;html&#62;&#10;&#60;head&#62;&#60;title&#62;Hello World&#60;/title&#62;&#60;/head&#62;&#10;&#60;body&#62;&#10;Hello World!&#60;br/&#62;&#10;&#60;%&#10;out.println(&#34;Your IP address is &#34; + request.getRemoteAddr());&#10;%&#62;&#10;&#60;/body&#62;&#10;&#60;/html&#62; 中文编码问题的解决如果我们要在页面正常显示中文，我们需要在 JSP 文件头部添加以下代码：&lt;&gt;1&#60;%@ page language=&#34;java&#34; contentType=&#34;text/html; charset=UTF-8&#34;&#10; pageEncoding=&#34;UTF-8&#34;%&#62; 接下来我们将以上程序修改为：1&#60;%@ page language=&#34;java&#34; contentType=&#34;text/html; charset=UTF-8&#34;&#10; pageEncoding=&#34;UTF-8&#34;%&#62;&#10;&#60;!DOCTYPE html&#62;&#10;&#60;html&#62;&#10;&#60;head&#62;&#10;&#60;meta charset=&#34;utf-8&#34;&#62;&#10;&#60;title&#62;&#33756;&#40479;&#25945;&#31243;(runoob.com)&#60;/title&#62;&#10;&#60;/head&#62;&#10;&#60;body&#62;&#10;Hello World!&#60;br/&#62;&#10;&#60;%&#10;out.println(&#34;&#20320;&#30340; IP &#22320;&#22336; &#34; + request.getRemoteAddr());&#10;%&#62;&#10;&#60;/body&#62;&#10;&#60;/html&#62; 这样中文就可以正常显示了。 JSP表达式一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。由于表达式的值会被转化成String，所以您可以在一个文本行中使用表达式而不用去管它是否是HTML标签。表达式元素中可以包含任何符合Java语言规范的表达式，但是不能使用分号来结束表达式。JSP表达式的语法格式：&lt;%= 表达式 %&gt;程序示例：1&#60;%@ page language=&#34;java&#34; contentType=&#34;text/html; charset=UTF-8&#34;&#10; pageEncoding=&#34;UTF-8&#34;%&#62;&#10;&#60;!DOCTYPE html&#62;&#10;&#60;html&#62;&#10;&#60;head&#62;&#10;&#60;meta charset=&#34;utf-8&#34;&#62;&#10;&#60;title&#62;&#33756;&#40479;&#25945;&#31243;(runoob.com)&#60;/title&#62;&#10;&#60;/head&#62;&#10;&#60;body&#62;&#10;&#60;p&#62;&#10; &#20170;&#22825;&#30340;&#26085;&#26399;&#26159;: &#60;%= (new java.util.Date()).toLocaleString()%&#62;&#10;&#60;/p&#62;&#10;&#60;/body&#62; &#10;&#60;/html&#62; JSP注释1&#60;%@ page language=&#34;java&#34; contentType=&#34;text/html; charset=UTF-8&#34;&#10; pageEncoding=&#34;UTF-8&#34;%&#62;&#10;&#60;!DOCTYPE html&#62;&#10;&#60;html&#62;&#10;&#60;head&#62;&#10;&#60;meta charset=&#34;utf-8&#34;&#62;&#10;&#60;title&#62;&#33756;&#40479;&#25945;&#31243;(runoob.com)&#60;/title&#62;&#10;&#60;/head&#62;&#10;&#60;body&#62;&#10;&#60;%-- &#35813;&#37096;&#20998;&#27880;&#37322;&#22312;&#32593;&#39029;&#20013;&#19981;&#20250;&#34987;&#26174;&#31034;--%&#62; &#10;&#60;p&#62;&#10; &#20170;&#22825;&#30340;&#26085;&#26399;&#26159;: &#60;%= (new java.util.Date()).toLocaleString()%&#62;&#10;&#60;/p&#62;&#10;&#60;/body&#62; &#10;&#60;/html&#62; 运行后得到以下结果：今天的日期是: 2017-1-6 20:39:30不同情况下使用注释的语法规则： 语法 描述 &lt;%– 注释 –%&gt; JSP注释，注释内容不会被发送至浏览器甚至不会被编译 HTML注释，通过浏览器查看网页源代码时可以看见注释内容 &lt;\\% 代表静态 &lt;%常量 %> 代表静态 %&gt; 常量 \\’ 在属性中使用的单引号 \\” 在属性中使用的双引号 JSP指令JSP指令用来设置与整个JSP页面相关的属性。JSP指令语法格式：&lt;%@ directive attribute=&quot;value&quot; %&gt; 指令 描述 &lt;%@ page … %&gt; 定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等 &lt;%@ include … %&gt; 包含其他文件 &lt;%@ taglib … %&gt; 引入标签库的定义，可以是自定义标签","categories":[],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://liuzhe6.github.io/tags/jsp/"}]},{"title":"jsp使用项目路径之外的图片方法","slug":"jsp使用项目路径之外的图片方法","date":"2016-08-06T10:21:53.000Z","updated":"2017-01-06T11:05:43.667Z","comments":true,"path":"2016/08/06/jsp使用项目路径之外的图片方法/","link":"","permalink":"http://liuzhe6.github.io/2016/08/06/jsp使用项目路径之外的图片方法/","excerpt":"","text":"一个java web项目，把图片放在项目目录或者tomcat目录 可能会出现一些问题，那么我们可以放在项目目录之外，甚至可以放到不同的磁盘上，那么就需要在tomcat设置虚拟目录。 在tomcat的conf/server.xml中设置虚拟路径在tomcat下的conf/server.xml中增加一个代码 在中间如下： 1&#60;!--&#22686;&#21152;&#30340;--path=&#34;/&#34394;&#25311;&#21517;&#34; docBase=&#34;&#34394;&#25311;&#36335;&#24452;&#34; -&#62; &#10;&#60;Context path=&#34;/virtual&#34; docBase=&#34;D:\\upload\\&#34; reloadable=&#34;true&#34;&#62;&#60;/Context&#62; 在jsp中这样使用 1&#60;img src=&#34;/virtual/1.jsp&#34;&#62;","categories":[],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://liuzhe6.github.io/tags/jsp/"}]},{"title":"JFinal上传图片及其重命名","slug":"JFinal上传图片及其重命名","date":"2016-08-01T09:34:12.000Z","updated":"2017-01-06T11:03:46.537Z","comments":true,"path":"2016/08/01/JFinal上传图片及其重命名/","link":"","permalink":"http://liuzhe6.github.io/2016/08/01/JFinal上传图片及其重命名/","excerpt":"","text":"一、表单处理1&#60;form action=&#34;applicant/changeInformation&#34; method=&#34;post&#34; enctype=&#34;multipart/form-data&#34; &#62;&#10;&#9;&#60;input type=&#34;file&#34; name=&#34;file&#34; /&#62;&#10;&#9;&#60;input type=&#34;text&#34; name=&#34;username&#34;/&#62;&#10;&#9;&#60;input type=&#34;password&#34; name=&#34;password&#34;/&#62;&#10;&#60;/form&#62; 二、在后台的配置我们需要在Controller中得到表单里的三个东西，因为我们在客户端的请求为multipart request(form 表单使用了enctype=”multipart/form-data”)， 那么必须先调用getFile系列的方法才能使用getPara系列的方法正常工作，因为multipart request需要通过getFile系列方法解析请求体中的数据，包括参数 我们设置上传文件的路径为“D:/Activity_Registration_System/user_img”那么，在jfinal的config中设置一个基础上传路径 1@Override&#10;public void configConstant(Constants me) &#123;&#10;&#9;// TODO Auto-generated method stub&#10;&#9;PropKit.use(&#34;SQLConfig.txt&#34;);&#10;&#9;me.setDevMode(PropKit.getBoolean(&#34;devMode&#34;));&#10;&#9;me.setViewType(ViewType.JSP);&#10;&#9;//&#35774;&#32622;&#19978;&#20256;&#30340;&#22522;&#30784;&#36335;&#24452;,&#35774;&#32622;&#22312;D&#30424;&#30340;Activity_Registration_System&#25991;&#20214;&#22841;&#19979;&#38754;&#10;&#9;me.setBaseUploadPath(&#34;D:/Activity_Registration_System/&#34;);&#10;&#125; 三、在Controller里的配置接下来，在Controller里面得到文件以及数据，并把文件保存在这个目录下1&#10;//&#20808;&#20351;&#29992;getFile()&#33719;&#24471;&#19978;&#20256;&#30340;&#25991;&#20214;,&#24182;&#23384;&#22312; &#22522;&#30784;&#36335;&#24452;+user_img &#36825;&#20010;&#32477;&#23545;&#36335;&#24452;&#19979;&#38754;&#10;String realpath = &#34;user_img&#34;;&#10;UploadFile uf = getFile(&#34;header&#34;,realpath); 接下来获取其他数据1String username = getPara(&#34;username&#34;);&#10;System.out.println(&#34;username:&#34;+username);&#10;String email = getPara(&#34;email&#34;);&#10;System.out.println(&#34;email:&#34;+email); 四、对刚刚已经上传成功的文件进行重命名1//&#39318;&#20808;&#25105;&#20204;&#35201;&#33719;&#21462;&#25991;&#20214;&#30340;&#25299;&#23637;&#21517;&#65292;&#25152;&#20197;&#35201;&#25226;&#25991;&#20214;&#21407;&#21517;&#31216;&#36827;&#34892;&#25286;&#20998;&#10;String fileName = file.getName();&#10;String extName = fileName.substring(fileName.lastIndexOf(&#34;.&#34;)+ 1);&#9;//&#33719;&#21462;&#25299;&#23637;&#21517;,&#25353;&#29031; &#34;.&#34; &#20998;&#38548;&#24320;&#30340;&#26368;&#21518;&#19968;&#20010;&#23383;&#31526;&#20018;&#10;&#10;//&#25509;&#19979;&#26469;&#65292;&#33719;&#21462;&#21018;&#21018;&#19978;&#20256;&#30340;&#25991;&#20214;&#30340;&#23616;&#23545;&#36335;&#24452;&#10;String [] test = file.getPath().split(&#34;user_img&#34;);&#10;//&#36825;&#37324;&#20043;&#25152;&#20197;&#25353;user_img &#36827;&#34892;&#20998;&#21106;&#26159;&#22240;&#20026;&#26377;&#20010;bug &#22914;&#26524;&#25353;&#29031;\\&#36827;&#34892;&#20998;&#21106;&#65292;&#21017;&#24212;&#20889;&#20026;spilt(&#34;\\\\&#34;) &#20294;&#26159;&#32534;&#35793;&#22120;&#20250;&#35299;&#26512;&#20026;&#25353;&#23383;&#31526;&#20018;\\\\&#36827;&#34892;&#20998;&#21106;&#65292;&#25152;&#20197;&#20250;&#20986;&#29616;&#38382;&#39064;&#10;&#10;String road = &#34;&#34;;&#10;&#9;&#9;for (int i = 0 ;i &#60; test.length;i++)&#123;&#10;&#9;&#9;&#9;if (i == test.length-1)&#123;&#10;&#9;&#9;&#9;&#9;break;&#10;&#9;&#9;&#9;&#125;&#10;&#9;&#9;&#9;road += test[i];&#10;&#9;&#9;&#125;&#10;&#9;&#9;road += &#34;user_img\\\\&#34; + getSessionAttr(&#34;student_id&#34;)+&#34;.&#34; + extName;//&#25105;&#36825;&#37324;&#25353;&#29031;&#23398;&#21495;&#36827;&#34892;&#21629;&#21517;&#10;&#10;//&#27492;&#26102;road&#30340;&#20540;&#20026; &#25991;&#20214;&#30340; &#32477;&#23545;&#36335;&#24452; + &#26032;&#21517;&#31216;&#10;file.renameTo(new File(road)); 这样，简单的单文件、数据上传以及重命名就完成了。 这是我的第一篇博客，欢迎大家批评指正","categories":[],"tags":[{"name":"JFinal","slug":"JFinal","permalink":"http://liuzhe6.github.io/tags/JFinal/"}]}]}