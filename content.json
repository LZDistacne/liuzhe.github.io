{"meta":{"title":"A Coder's Blog","subtitle":"有关计算机的点点滴滴","description":"哪怕天再高那又怎样，踮起脚尖就更靠近阳光","author":"刘哲","url":"http://liuzhe6.github.io"},"pages":[{"title":"","date":"2017-01-25T04:54:32.982Z","updated":"2017-01-25T04:52:55.907Z","comments":true,"path":"baidu_verify_e0OSN9VAuH.html","permalink":"http://liuzhe6.github.io/baidu_verify_e0OSN9VAuH.html","excerpt":"","text":"e0OSN9VAuH"},{"title":"tags","date":"2017-01-24T07:22:46.000Z","updated":"2017-01-24T07:23:36.122Z","comments":false,"path":"tags/index.html","permalink":"http://liuzhe6.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-01-24T07:24:57.000Z","updated":"2017-01-24T07:25:12.785Z","comments":false,"path":"categories/index.html","permalink":"http://liuzhe6.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Android显示手机图片","slug":"Android显示手机图片","date":"2017-02-08T08:33:32.000Z","updated":"2017-02-08T08:39:52.870Z","comments":true,"path":"2017/02/08/Android显示手机图片/","link":"","permalink":"http://liuzhe6.github.io/2017/02/08/Android显示手机图片/","excerpt":"","text":"点击按钮后12345678910111213Button chooseFromAlbum = (Button) findViewById(R.id.choose_from_album); chooseFromAlbum.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //如果没有读和写SD卡权限时 if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)&#123; ActivityCompat.requestPermissions(MainActivity.this, new String[] &#123;Manifest.permission.WRITE_EXTERNAL_STORAGE&#125; ,1); &#125; else &#123; openAlbum(); &#125; &#125; &#125;); 动态申请读写SD卡权限12345678910111213141516171819202122//动态申请权限 返回结果@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode)&#123; case 1: if (grantResults.length &gt;0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED)&#123; openAlbum(); &#125; else &#123; Toast.makeText(MainActivity.this , &quot;You denied the permission&quot; , Toast.LENGTH_SHORT).show(); &#125; break; default: break; &#125;&#125;private void openAlbum() &#123; Intent intent = new Intent(&quot;android.intent.action.GET_CONTENT&quot;); intent.setType(&quot;image/*&quot;); startActivityForResult(intent , CHOOSE_PHOTO);&#125; 对启动活动时返回结果的判断1234567891011121314151617181920@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; switch (requestCode)&#123; case CHOOSE_PHOTO: if (resultCode == RESULT_OK)&#123; //判断手机系统版本号 if (Build.VERSION.SDK_INT &gt;= 19)&#123; //4.4及以上的系统用这个方法处理图片 handleImageOnKitKat(data); &#125; else &#123; //4.4以下的系统的用这个方法处理图片 handleImageBeforeKitKat(data); &#125; &#125; break; default: break; &#125; &#125; 分别对Android4.4以上及以下的设备进行操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@TargetApi(19) private void handleImageOnKitKat(Intent data) &#123; String imagePath = null; Uri uri = data.getData(); Log.d(TAG, &quot;handleImageOnKitKat: uri :&quot; + uri); if (DocumentsContract.isDocumentUri(this,uri))&#123; //如果是document类型的Uri,则通过document id处理 String docId = DocumentsContract.getDocumentId(uri); Log.d(TAG, &quot;handleImageOnKitKat: 封装的docID : &quot; + docId); if (&quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority()))&#123; //解析出数字格式的id String id = docId.split(&quot;:&quot;)[1]; String selection = MediaStore.Images.Media._ID + &quot;=&quot; + id; Log.d(TAG, &quot;handleImageOnKitKat: selection ;&quot;+selection); imagePath = getImagePath(MediaStore.Images.Media.EXTERNAL_CONTENT_URI ,selection); &#125; else if (&quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority()))&#123; Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;), Long.valueOf(docId)); imagePath = uri.getPath(); &#125; &#125; else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme()))&#123; //如果是content类型的uri,则使用普通方式处理 imagePath = getImagePath(uri, null); &#125; else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme()))&#123; //如果是file类型的Uri,直接获取图片路径即可 imagePath = uri.getPath(); &#125; //根据路径显示图片 displayImage(imagePath); &#125; private void handleImageBeforeKitKat(Intent data) &#123; Uri uri = data.getData(); String imagePath = getImagePath(uri,null); displayImage(imagePath); &#125; //处理Uri，得到真实路径 private String getImagePath(Uri uri, String selection) &#123; String path = null; //通过Uri 和 selection来获取真实的图片路径 Cursor cursor = getContentResolver().query(uri, null,selection , null , null); if (cursor != null)&#123; if (cursor.moveToFirst())&#123; path = cursor.getString(cursor.getColumnIndex(MediaStore.Images.Media.DATA)); &#125; cursor.close(); &#125; return path; &#125; private void displayImage(String imagePath) &#123; if (imagePath != null)&#123; Bitmap bitmap = BitmapFactory.decodeFile(imagePath); picture.setImageBitmap(bitmap); &#125; else &#123; Toast.makeText(this, &quot;failed to get image&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://liuzhe6.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://liuzhe6.github.io/tags/Android/"}]},{"title":"Android将数据存储到文件中","slug":"Android将数据存储到文件中","date":"2017-01-19T02:27:48.000Z","updated":"2017-02-08T08:57:06.425Z","comments":true,"path":"2017/01/19/Android将数据存储到文件中/","link":"","permalink":"http://liuzhe6.github.io/2017/01/19/Android将数据存储到文件中/","excerpt":"","text":"Android开发中存储文件文件默认存储位置为 /data/data//files/目录下的主要有两种模式可选，MODE_PRIVATE和MODE_APPEND。MODE_PRIVATE：是默认操作模式，表示当指定同样文件名的时候，所写的内容会覆盖原文件中的内容。MODE_APPEND：表示如果该文件已经存在，就往文件里面追加内容，不存在就创建新文件。 下面是一段简单的代码示例：1234567891011121314151617181920public void save()&#123; String data = &quot;Data to save&quot;; FileOutputStream out = null; BufferedWriter writer = null; try&#123; out = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE); writer = new BufferedWriter(new OutputStreamWriter(out)); writer.write(data); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; finally &#123; try&#123; if (writer != null)&#123; writer.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://liuzhe6.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://liuzhe6.github.io/tags/Android/"},{"name":"数据存储","slug":"数据存储","permalink":"http://liuzhe6.github.io/tags/数据存储/"}]},{"title":"XML简介","slug":"XML简介","date":"2017-01-18T11:41:04.000Z","updated":"2017-02-08T09:11:43.004Z","comments":true,"path":"2017/01/18/XML简介/","link":"","permalink":"http://liuzhe6.github.io/2017/01/18/XML简介/","excerpt":"","text":"XML简介什么是XML可扩展标记语言是一种很像超文本标记语言的标记语言。它的设计宗旨是传输数据，而不是显示数据。它的标签没有被预定义。您需要自行定义标签。它被设计为具有自我描述性。它是W3C的推荐标准。 XML 树结构XML 文档形成了一种树结构，它从“根部”开始，然后扩展到“枝叶”。一个 XML 文档实例XML 使用简单的具有自我描述性的语法：第一行是 XML 声明。它定义 XML 的版本 (1.0) 和所使用的编码 (ISO-8859-1 = Latin-1/西欧字符集)。下一行描述文档的根元素（像在说：“本文档是一个便签”）：&lt;note&gt; 接下来 4 行描述根的 4 个子元素（to, from, heading 以及 body）：1234to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt; 最后一行定义根元素的结尾：&lt;/note&gt; 从本例可以设想，该 XML 文档包含了 John 给 George 的一张便签。 XML 文档形成一种树结构XML 文档必须包含根元素。该元素是所有其他元素的父元素。XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。所有元素均可拥有子元素：12345&lt;root&gt; &lt;child&gt; &lt;subchild&gt;.....&lt;/subchild&gt; &lt;/child&gt;&lt;/root&gt; 父、子以及同胞等术语用于描述元素之间的关系。父元素拥有子元素。相同层级上的子元素成为同胞（兄弟或姐妹）。所有元素均可拥有文本内容和属性（类似 HTML 中）。 实例 上图表示下面的 XML 中的一本书：1234567891011121314151617181920&lt;bookstore&gt;&lt;book category=&quot;COOKING&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt; &lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt;&lt;book category=&quot;CHILDREN&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt;&lt;book category=&quot;WEB&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; 例子中的根元素是 。文档中的所有 元素都被包含在 中。 元素有 4 个子元素：、&lt; author&gt;、、。 XML 语法规则XML 的语法规则很简单，且很有逻辑。这些规则很容易学习，也很容易使用。所有 XML 元素都须有关闭标签在 HTML，经常会看到没有关闭标签的元素：12&lt;p&gt;This is a paragraph&lt;p&gt;This is another paragraph 在 XML 中，省略关闭标签是非法的。所有元素都必须有关闭标签：12&lt;p&gt;This is a paragraph&lt;/p&gt;&lt;p&gt;This is another paragraph&lt;/p&gt; XML 标签对大小写敏感XML 元素使用 XML 标签进行定义。XML 标签对大小写敏感。在 XML 中，标签 与标签 是不同的。必须使用相同的大小写来编写打开标签和关闭标签：123&lt;Message&gt;这是错误的。&lt;/message&gt;&lt;message&gt;这是正确的。&lt;/message&gt; XML 必须正确地嵌套在 HTML 中，常会看到没有正确嵌套的元素：&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt;在 XML 中，所有元素都必须彼此正确地嵌套：&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;在上例中，正确嵌套的意思是：由于 元素是在 元素内打开的，那么它必须在 元素内关闭。 XML 文档必须有根元素XML 文档必须有一个元素是所有其他元素的父元素。该元素称为根元素。12345&lt;root&gt; &lt;child&gt; &lt;subchild&gt;.....&lt;/subchild&gt; &lt;/child&gt;&lt;/root&gt; XML 的属性值须加引号与 HTML 类似，XML 也可拥有属性（名称/值的对）。在 XML 中，XML 的属性值须加引号。请研究下面的两个 XML 文档。第一个是错误的，第二个是正确的：12345678&lt;note date=08/08/2008&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;/note&gt; &lt;note date=&quot;08/08/2008&quot;&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;/note&gt; 在第一个文档中的错误是，note 元素中的 date 属性没有加引号。 实体引用在 XML 中，一些字符拥有特殊的意义。如果你把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。这样会产生 XML 错误：&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt;为了避免这个错误，请用实体引用来代替 “&lt;” 字符：&lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt;在 XML 中，有 5 个预定义的实体引用： 注释：在 XML 中，只有字符 “&lt;” 和 “&amp;” 确实是非法的。大于号是合法的，但是用实体引用来代替它是一个好习惯。 XML 中的注释在 XML 中编写注释的语法与 HTML 的语法很相似：&lt;!-- This is a comment --&gt; 在 XML 中，空格会被保留HTML 会把多个连续的空格字符裁减（合并）为一个：12HTML: Hello my name is David.输出: Hello my name is David. 在 XML 中，文档中的空格不会被删节。 XML元素XML 文档包含 XML 元素。什么是 XML 元素？XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分。元素可包含其他元素、文本或者两者的混合物。元素也可以拥有属性。1234567891011121314&lt;bookstore&gt;&lt;book category=&quot;CHILDREN&quot;&gt; &lt;title&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt;&lt;book category=&quot;WEB&quot;&gt; &lt;title&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; 在上例中， 和 都拥有元素内容，因为它们包含了其他元素。 只有文本内容，因为它仅包含文本。在上例中，只有 元素拥有属性 (category=”CHILDREN”)。 XML 命名规则XML 元素必须遵循以下命名规则： 名称可以含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字符 “xml”（或者 XML、Xml）开始 名称不能包含空格 可使用任何名称，没有保留的字词。 最佳命名习惯使名称具有描述性。使用下划线的名称也很不错。名称应当比较简短，比如：，而不是：。避免 “-“ 字符。如果您按照这样的方式进行命名：”first-name”，一些软件会认为你需要提取第一个单词。避免 “.” 字符。如果您按照这样的方式进行命名：”first.name”，一些软件会认为 “name” 是对象 “first” 的属性。避免 “:” 字符。冒号会被转换为命名空间来使用（稍后介绍）。XML 文档经常有一个对应的数据库，其中的字段会对应 XML 文档中的元素。有一个实用的经验，即使用数据库的名称规则来命名 XML 文档中的元素。非英语的字母比如 éòá 也是合法的 XML 元素名，不过需要留意当软件开发商不支持这些字符时可能出现的问题。 XML 元素是可扩展的XML 元素是可扩展，以携带更多的信息。请看下面这个 XML 例子：12345&lt;note&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt; 让我们设想一下，我们创建了一个应用程序，可将 、 以及 元素提取出来，并产生以下的输出：12345MESSAGETo: GeorgeFrom: JohnDon&apos;t forget the meeting! 想象一下，之后这个 XML 文档作者又向这个文档添加了一些额外的信息：1234567&lt;note&gt;&lt;date&gt;2008-08-08&lt;/date&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt; 那么这个应用程序会中断或崩溃吗？不会。这个应用程序仍然可以找到 XML 文档中的 、 以及 元素，并产生同样的输出。XML 的优势之一，就是可以经常在不中断应用程序的情况进行扩展。 XML 属性XML 元素可以在开始标签中包含属性，类似 HTML。属性 (Attribute) 提供关于元素的额外（附加）信息。 XML 属性从 HTML，你会回忆起这个：&lt;img src=&quot;computer.gif&quot;&gt;。”src” 属性提供有关 元素的额外信息。在 HTML 中（以及在 XML 中），属性提供有关元素的额外信息：12&lt;img src=&quot;computer.gif&quot;&gt;&lt;a href=&quot;demo.asp&quot;&gt; 属性通常提供不属于数据组成部分的信息。在下面的例子中，文件类型与数据无关，但是对需要处理这个元素的软件来说却很重要：&lt;file type=&quot;gif&quot;&gt;computer.gif&lt;/file&gt; XML 属性必须加引号属性值必须被引号包围，不过单引号和双引号均可使用。比如一个人的性别，person 标签可以这样写：&lt;person sex=&quot;female&quot;&gt;或者这样也可以：&lt;person sex=&#39;female&#39;&gt;注释：如果属性值本身包含双引号，那么有必要使用单引号包围它，就像这个例子：&lt;gangster name=&#39;George &quot;Shotgun&quot; Ziegler&#39;&gt;或者可以使用实体引用：&lt;gangster name=&quot;George &amp;quot;Shotgun&amp;quot; Ziegler&quot;&gt; XML 元素 vs. 属性请看这些例子：12345678910&lt;person sex=&quot;female&quot;&gt; &lt;firstname&gt;Anna&lt;/firstname&gt; &lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt; &lt;person&gt; &lt;sex&gt;female&lt;/sex&gt; &lt;firstname&gt;Anna&lt;/firstname&gt; &lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt; 在第一个例子中，sex 是一个属性。在第二个例子中，sex 则是一个子元素。两个例子均可提供相同的信息。没有什么规矩可以告诉我们什么时候该使用属性，而什么时候该使用子元素。我的经验是在 HTML 中，属性用起来很便利，但是在 XML 中，您应该尽量避免使用属性。如果信息感觉起来很像数据，那么请使用子元素吧。 我最喜欢的方式下面的三个 XML 文档包含完全相同的信息：第一个例子中使用了 date 属性：123456&lt;note date=&quot;08/08/2008&quot;&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt; 第二个例子中使用了 date 元素：1234567&lt;note&gt;&lt;date&gt;08/08/2008&lt;/date&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt; 第三个例子中使用了扩展的 date 元素（这是我的最爱）：1234567891011&lt;note&gt;&lt;date&gt; &lt;day&gt;08&lt;/day&gt; &lt;month&gt;08&lt;/month&gt; &lt;year&gt;2008&lt;/year&gt;&lt;/date&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt; 以上内容摘自 http://www.w3school.com.cn/xml/index.asp","categories":[{"name":"Java web","slug":"Java-web","permalink":"http://liuzhe6.github.io/categories/Java-web/"}],"tags":[{"name":"XML","slug":"XML","permalink":"http://liuzhe6.github.io/tags/XML/"}]},{"title":"jstl简介","slug":"jstl简介","date":"2017-01-18T11:16:30.000Z","updated":"2017-02-08T08:58:05.385Z","comments":true,"path":"2017/01/18/jstl简介/","link":"","permalink":"http://liuzhe6.github.io/2017/01/18/jstl简介/","excerpt":"","text":"JSP标准标签库JSTL核心标签核心标签是最常用的JSTL标签。引用核心标签库的语法如下：12&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; logo 格式化标签JSTL格式化标签用来格式化并输出文本、日期、时间、数字。引用格式化标签库的语法如下：12&lt;%@ taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt; logo SQL标签JSTL SQL标签库提供了与关系型数据库（Oracle，MySQL，SQL Server等等）进行交互的标签。引用SQL标签库的语法如下：12&lt;%@ taglib prefix=&quot;sql&quot; uri=&quot;http://java.sun.com/jsp/jstl/sql&quot; %&gt; logo XML标签12&lt;%@ taglib prefix=&quot;x&quot; uri=&quot;http://java.sun.com/jsp/jstl/xml&quot; %&gt; 在使用xml标签前，你必须将XML 和 XPath 的相关包拷贝至你的\\lib下: XercesImpl.jar下载地址： http://www.apache.org/dist/xerces/j/ xalan.jar下载地址： http://xml.apache.org/xalan-j/index.html JSTL函数JSTL包含一系列标准函数，大部分是通用的字符串处理函数。引用JSTL函数库的语法如下：12&lt;%@ taglib prefix=&quot;fn&quot; uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; %&gt; logo 以上内容摘自 http://www.runoob.com/jsp/jsp-jstl.html","categories":[{"name":"Java web","slug":"Java-web","permalink":"http://liuzhe6.github.io/categories/Java-web/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://liuzhe6.github.io/tags/jsp/"},{"name":"jstl","slug":"jstl","permalink":"http://liuzhe6.github.io/tags/jstl/"}]},{"title":"jQuery ajax","slug":"jQuery-ajax","date":"2017-01-16T07:55:18.000Z","updated":"2017-02-08T08:57:42.096Z","comments":true,"path":"2017/01/16/jQuery-ajax/","link":"","permalink":"http://liuzhe6.github.io/2017/01/16/jQuery-ajax/","excerpt":"","text":"jQuery ajax实例通过 AJAX 加载一段文本：jQuery 代码：123456$(document).ready(function()&#123; $(&quot;#b01&quot;).click(function()&#123; htmlobj=$.ajax(&#123;url:&quot;/jquery/test1.txt&quot;,async:false&#125;); $(&quot;#myDiv&quot;).html(htmlobj.responseText); &#125;);&#125;); HTML 代码：12&lt;div id=&quot;myDiv&quot;&gt;&lt;h2&gt;Let AJAX change this text&lt;/h2&gt;&lt;/div&gt;&lt;button id=&quot;b01&quot; type=&quot;button&quot;&gt;Change Content&lt;/button&gt; 定义和用法ajax() 方法通过 HTTP 请求加载远程数据。该方法是 jQuery 底层 AJAX 实现。简单易用的高层实现见 $.get, $.post 等。$.ajax() 返回其创建的 XMLHttpRequest 对象。大多数情况下你无需直接操作该函数，除非你需要操作不常用的选项，以获得更多的灵活性。最简单的情况下，$.ajax() 可以不带任何参数直接使用。注意：所有的选项都可以通过 $.ajaxSetup() 函数来全局设置。语法1jQuery.ajax([settings]) logo 参数options类型：Object可选。AJAX 请求设置。所有选项都是可选的。 async类型：Boolean默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。 beforeSend(XHR)类型：Function发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头。XMLHttpRequest 对象是唯一的参数。这是一个 Ajax 事件。如果返回 false 可以取消本次 ajax 请求。 cache类型：Boolean默认值: true，dataType 为 script 和 jsonp 时默认为 false。设置为 false 将不缓存此页面。jQuery 1.2 新功能。 complete(XHR, TS)类型：Function请求完成后回调函数 (请求成功或失败之后均调用)。参数： XMLHttpRequest 对象和一个描述请求类型的字符串。这是一个 Ajax 事件。 contentType类型：String默认值: “application/x-www-form-urlencoded”。发送信息至服务器时内容编码类型。默认值适合大多数情况。如果你明确地传递了一个 content-type 给 $.ajax() 那么它必定会发送给服务器（即使没有数据要发送）。 context类型：Object这个对象用于设置 Ajax 相关回调函数的上下文。也就是说，让回调函数内 this 指向这个对象（如果不设定这个参数，那么 this 就指向调用本次 AJAX 请求时传递的 options 参数）。比如指定一个 DOM 元素作为 context 参数，这样就设置了 success 回调函数的上下文为这个 DOM 元素。就像这样：123$.ajax(&#123; url: &quot;test.html&quot;, context: document.body, success: function()&#123; $(this).addClass(&quot;done&quot;); &#125;&#125;); data类型：String发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[“bar1”, “bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。 dataFilter类型：Function给 Ajax 返回的原始数据的进行预处理的函数。提供 data 和 type 两个参数：data 是 Ajax 返回的原始数据，type 是调用 jQuery.ajax 时提供的 dataType 参数。函数返回的值将由 jQuery 进一步处理。 dataType类型：String预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断，比如 XML MIME 类型就被识别为 XML。在 1.4 中，JSON 就会生成一个 JavaScript 对象，而 script 则会执行这个脚本。随后服务器端返回的数据会根据这个值解析后，传递给回调函数。可用值:“xml”: 返回 XML 文档，可用 jQuery 处理。“html”: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。“script”: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 “cache” 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载）“json”: 返回 JSON 数据 。“jsonp”: JSONP 格式。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。“text”: 返回纯文本字符串 error类型：Function默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是 “timeout”, “error”, “notmodified” 和 “parsererror”。这是一个 Ajax 事件。 global类型：Boolean是否触发全局 AJAX 事件。默认值: true。设置为 false 将不会触发全局 AJAX 事件，如 ajaxStart 或 ajaxStop 可用于控制不同的 Ajax 事件。 ifModified类型：Boolean仅在服务器数据改变时获取新数据。默认值: false。使用 HTTP 包 Last-Modified 头信息判断。在 jQuery 1.4 中，它也会检查服务器指定的 ‘etag’ 来确定数据没有被修改过。 jsonp类型：String在一个 jsonp 请求中重写回调函数的名字。这个值用来替代在 “callback=?” 这种 GET 或 POST 请求中 URL 参数里的 “callback” 部分，比如 {jsonp:’onJsonPLoad’} 会导致将 “onJsonPLoad=?” 传给服务器。 jsonpCallback类型：String为 jsonp 请求指定一个回调函数名。这个值将用来取代 jQuery 自动生成的随机函数名。这主要用来让 jQuery 生成度独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。你也可以在想让浏览器缓存 GET 请求的时候，指定这个回调函数名。 password类型：String用于响应 HTTP 访问认证请求的密码processData类型：Boolean默认值: true。默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。 scriptCharset类型：String只有当请求时 dataType 为 “jsonp” 或 “script”，并且 type 是 “GET” 才会用于强制修改 charset。通常只在本地和远程的内容编码不同时使用。 success类型：Function请求成功后的回调函数。参数：由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串。这是一个 Ajax 事件。 traditional类型：Boolean如果你想要用传统的方式来序列化数据，那么就设置为 true。请参考工具分类下面的 jQuery.param 方法。 timeout类型：Number设置请求超时时间（毫秒）。此设置将覆盖全局设置。 type类型：String默认值: “GET”)。请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。 url类型：String默认值: 当前页地址。发送请求的地址。 username类型：String用于响应 HTTP 访问认证请求的用户名。 xhr类型：Function需要返回一个 XMLHttpRequest 对象。默认在 IE 下是 ActiveXObject 而其他情况下是 XMLHttpRequest 。用于重写或者提供一个增强的 XMLHttpRequest 对象。这个参数在 jQuery 1.3 以前不可用。 回调函数如果要处理 $.ajax() 得到的数据，则需要使用回调函数：beforeSend、error、dataFilter、success、complete。 beforeSend在发送请求之前调用，并且传入一个 XMLHttpRequest 作为参数。 error在请求出错时调用。传入 XMLHttpReques 对象，描述错误类型的字符串以及一个异常对象（如果有的话） dataFilter在请求成功之后调用。传入返回的数据以及 “dataType” 参数的值。并且必须返回新的数据（可能是处理过的）传递给 success 回调函数。 success当请求之后调用。传入返回后的数据，以及包含成功代码的字符串。 complete当请求完成之后调用这个函数，无论成功或失败。传入 XMLHttpRequest 对象，以及一个包含成功或错误代码的字符串。 数据类型$.ajax() 函数依赖服务器提供的信息来处理返回的数据。如果服务器报告说返回的数据是 XML，那么返回的结果就可以用普通的 XML 方法或者 jQuery 的选择器来遍历。如果见得到其他类型，比如 HTML，则数据就以文本形式来对待。通过 dataType 选项还可以指定其他不同数据处理方式。除了单纯的 XML，还可以指定 html、json、jsonp、script 或者 text。其中，text 和 xml 类型返回的数据不会经过处理。数据仅仅简单的将 XMLHttpRequest 的 responseText 或 responseHTML 属性传递给 success 回调函数。 注意：我们必须确保网页服务器报告的 MIME 类型与我们选择的 dataType 所匹配。比如说，XML的话，服务器端就必须声明 text/xml 或者 application/xml 来获得一致的结果。如果指定为 html 类型，任何内嵌的 JavaScript 都会在 HTML 作为一个字符串返回之前执行。类似地，指定 script 类型的话，也会先执行服务器端生成 JavaScript，然后再把脚本作为一个文本数据返回。 如果指定为 json 类型，则会把获取到的数据作为一个 JavaScript 对象来解析，并且把构建好的对象作为结果返回。为了实现这个目的，它首先尝试使用 JSON.parse()。如果浏览器不支持，则使用一个函数来构建。 JSON 数据是一种能很方便通过 JavaScript 解析的结构化数据。如果获取的数据文件存放在远程服务器上（域名不同，也就是跨域获取数据），则需要使用 jsonp 类型。使用这种类型的话，会创建一个查询字符串参数 callback=? ，这个参数会加在请求的 URL 后面。服务器端应当在 JSON 数据前加上回调函数名，以便完成一个有效的 JSONP 请求。如果要指定回调函数的参数名来取代默认的 callback，可以通过设置 $.ajax() 的 jsonp 参数。 注意：JSONP 是 JSON 格式的扩展。它要求一些服务器端的代码来检测并处理查询字符串参数。如果指定了 script 或者 jsonp 类型，那么当从服务器接收到数据时，实际上是用了 标签而不是 XMLHttpRequest 对象。这种情况下，$.ajax() 不再返回一个 XMLHttpRequest 对象，并且也不会传递事件处理函数，比如 beforeSend。 发送数据到服务器默认情况下，Ajax 请求使用 GET 方法。如果要使用 POST 方法，可以设定 type 参数值。这个选项也会影响 data 选项中的内容如何发送到服务器。 data 选项既可以包含一个查询字符串，比如 key1=value1&amp;key2=value2 ，也可以是一个映射，比如 {key1: ‘value1’, key2: ‘value2’} 。如果使用了后者的形式，则数据再发送器会被转换成查询字符串。这个处理过程也可以通过设置 processData 选项为 false 来回避。如果我们希望发送一个 XML 对象给服务器时，这种处理可能并不合适。并且在这种情况下，我们也应当改变 contentType 选项的值，用其他合适的 MIME 类型来取代默认的 application/x-www-form-urlencoded 。 高级选项global 选项用于阻止响应注册的回调函数，比如 .ajaxSend，或者 ajaxError，以及类似的方法。这在有些时候很有用，比如发送的请求非常频繁且简短的时候，就可以在 ajaxSend 里禁用这个。 如果服务器需要 HTTP 认证，可以使用用户名和密码可以通过 username 和 password 选项来设置。 Ajax 请求是限时的，所以错误警告被捕获并处理后，可以用来提升用户体验。请求超时这个参数通常就保留其默认值，要不就通过 jQuery.ajaxSetup 来全局设定，很少为特定的请求重新设置 timeout 选项。 默认情况下，请求总会被发出去，但浏览器有可能从它的缓存中调取数据。要禁止使用缓存的结果，可以设置 cache 参数为 false。如果希望判断数据自从上次请求后没有更改过就报告出错的话，可以设置 ifModified 为 true。 scriptCharset 允许给 标签的请求设定一个特定的字符集，用于 script 或者 jsonp 类似的数据。当脚本和页面字符集不同时，这特别好用。 Ajax 的第一个字母是 asynchronous 的开头字母，这意味着所有的操作都是并行的，完成的顺序没有前后关系。$.ajax() 的 async 参数总是设置成true，这标志着在请求开始后，其他代码依然能够执行。强烈不建议把这个选项设置成 false，这意味着所有的请求都不再是异步的了，这也会导致浏览器被锁死。 $.ajax 函数返回它创建的 XMLHttpRequest 对象。通常 jQuery 只在内部处理并创建这个对象，但用户也可以通过 xhr 选项来传递一个自己创建的 xhr 对象。返回的对象通常已经被丢弃了，但依然提供一个底层接口来观察和操控请求。比如说，调用对象上的 .abort() 可以在请求完成前挂起请求。 以上内容全部摘自 WSchool","categories":[{"name":"Java web","slug":"Java-web","permalink":"http://liuzhe6.github.io/categories/Java-web/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://liuzhe6.github.io/tags/jQuery/"},{"name":"ajax","slug":"ajax","permalink":"http://liuzhe6.github.io/tags/ajax/"}]},{"title":"Ajax简介","slug":"Ajax简介","date":"2017-01-16T03:22:53.000Z","updated":"2017-02-08T08:56:34.941Z","comments":true,"path":"2017/01/16/Ajax简介/","link":"","permalink":"http://liuzhe6.github.io/2017/01/16/Ajax简介/","excerpt":"","text":"ajax开发AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。AJAX = 异步 JavaScript和XML（标准通用标记语言的子集）。AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个网页页面。 摘自百度百科 AJAX - 创建 XMLHttpRequest 对象XMLHttpRequest 是 AJAX 的基础。XMLHttpRequest 对象所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。创建 XMLHttpRequest 对象所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。创建 XMLHttpRequest 对象的语法：1variable=new XMLHttpRequest(); 老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：1variable=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); 为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：123456789var xmlhttp; if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; AJAX - 向服务器发送请求XMLHttpRequest 对象用于和服务器交换数据。向服务器发送请求如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：12xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,true);xmlhttp.send(); logo GET 还是 POST？与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 GET 请求一个简单的 GET 请求：12xmlhttp.open(&quot;GET&quot;,&quot;demo_get.asp&quot;,true);xmlhttp.send(); 在上面的例子中，您可能得到的是缓存的结果。为了避免这种情况，请向 URL 添加一个唯一的 ID：12xmlhttp.open(&quot;GET&quot;,&quot;demo_get.asp?t=&quot; + Math.random(),true);xmlhttp.send(); 如果您希望通过 GET 方法发送信息，请向 URL 添加信息：12xmlhttp.open(&quot;GET&quot;,&quot;demo_get2.asp?fname=Bill&amp;lname=Gates&quot;,true);xmlhttp.send(); POST 请求一个简单 POST 请求：12xmlhttp.open(&quot;POST&quot;,&quot;demo_post.asp&quot;,true);xmlhttp.send(); 如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader() 来添加 HTTP 头。然后在 send() 方法中规定您希望发送的数据：123xmlhttp.open(&quot;POST&quot;,&quot;ajax_test.asp&quot;,true);xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);xmlhttp.send(&quot;fname=Bill&amp;lname=Gates&quot;); logo url - 服务器上的文件open() 方法的 url 参数是服务器上文件的地址：xmlhttp.open(&quot;GET&quot;,&quot;ajax_test.asp&quot;,true);该文件可以是任何类型的文件，比如 .txt 和 .xml，或者服务器脚本文件，比如 .asp 和 .php （在传回响应之前，能够在服务器上执行任务）。 异步 - True 或 False？AJAX 指的是异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。XMLHttpRequest 对象如果要用于 AJAX 的话，其 open() 方法的 async 参数必须设置为 true：xmlhttp.open(&quot;GET&quot;,&quot;ajax_test.asp&quot;,true);对于 web 开发人员来说，发送异步请求是一个巨大的进步。很多在服务器执行的任务都相当费时。AJAX 出现之前，这可能会引起应用程序挂起或停止。通过 AJAX，JavaScript 无需等待服务器的响应，而是： 在等待服务器响应时执行其他脚本 当响应就绪后对响应进行处理 Async = true当使用 async=true 时，请规定在响应处于 onreadystatechange 事件中的就绪状态时执行的函数：123456789xmlhttp.onreadystatechange=function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; &#125; &#125;xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,true);xmlhttp.send(); Async = false如需使用 async=false，请将 open() 方法中的第三个参数改为 false：xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,false);我们不推荐使用 async=false，但是对于一些小型的请求，也是可以的。请记住，JavaScript 会等到服务器响应就绪才继续执行。如果服务器繁忙或缓慢，应用程序会挂起或停止。注释：当您使用 async=false 时，请不要编写 onreadystatechange 函数 - 把代码放到 send() 语句后面即可：123xmlhttp.open(&quot;GET&quot;,&quot;test1.txt&quot;,false);xmlhttp.send();document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; AJAX - 服务器响应服务器响应如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 responseText 属性如果来自服务器的响应并非 XML，请使用 responseText 属性。responseText 属性返回字符串形式的响应，因此您可以这样使用：document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText; responseXML 属性如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML 属性：请求 books.xml 文件，并解析响应： 12345678xmlDoc=xmlhttp.responseXML;txt=&quot;&quot;;x=xmlDoc.getElementsByTagName(&quot;ARTIST&quot;);for (i=0;i&lt;x.length;i++) &#123; txt=txt + x[i].childNodes[0].nodeValue + &quot;&lt;br /&gt;&quot;; &#125;document.getElementById(&quot;myDiv&quot;).innerHTML=txt; 以上内容来自 WSchool 点击","categories":[{"name":"Java web","slug":"Java-web","permalink":"http://liuzhe6.github.io/categories/Java-web/"}],"tags":[{"name":"Ajax","slug":"Ajax","permalink":"http://liuzhe6.github.io/tags/Ajax/"}]},{"title":"idea建立web service client时抛出SAXParseException解决办法","slug":"idea建立web-service-client时抛出SAXParseException解决办法","date":"2017-01-14T03:05:03.000Z","updated":"2017-02-08T08:57:19.192Z","comments":true,"path":"2017/01/14/idea建立web-service-client时抛出SAXParseException解决办法/","link":"","permalink":"http://liuzhe6.github.io/2017/01/14/idea建立web-service-client时抛出SAXParseException解决办法/","excerpt":"","text":"使用idea开发平台建立web service client抛出异常问题描述:抛出java.lang.AssertionError: org.xml.sax.SAXParseException; systemId: jar.. 问题原因:我使用的jdk版本为jdk8,而jdk8对jaxb-xjc-2.2.7有这个BUG,详细原因请点击查看 解决方法:在 jdk1.8.0/jre/lib 下创建一个文件 jaxp.properties,并且在文件中写下一句话javax.xml.accessExternalSchema = all 从CSDN整理并发表","categories":[{"name":"Java web","slug":"Java-web","permalink":"http://liuzhe6.github.io/categories/Java-web/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://liuzhe6.github.io/tags/idea/"},{"name":"web service client","slug":"web-service-client","permalink":"http://liuzhe6.github.io/tags/web-service-client/"},{"name":"异常","slug":"异常","permalink":"http://liuzhe6.github.io/tags/异常/"}]},{"title":"json语法","slug":"json语法","date":"2017-01-06T13:37:30.000Z","updated":"2017-02-08T08:57:47.568Z","comments":true,"path":"2017/01/06/json语法/","link":"","permalink":"http://liuzhe6.github.io/2017/01/06/json语法/","excerpt":"","text":"json语法JSON 语法是 JavaScript 语法的子集。JSON 语法规则 JSON 语法是 JavaScript 对象表示法语法的子集。数据在名称/值对中数据由逗号分隔花括号保存对象方括号保存数组JSON 名称/值对 JSON 数据的书写格式是：名称/值对。名称/值对包括字段名称（在双引号中），后面写一个冒号，然后是值：&quot;firstName&quot; : &quot;John&quot;这很容易理解，等价于这条 JavaScript 语句：firstName = &quot;John&quot;JSON 值 JSON 值可以是：数字（整数或浮点数）字符串（在双引号中）逻辑值（true 或 false）数组（在方括号中）对象（在花括号中）nullJSON 对象 JSON 对象在花括号中书写：对象可以包含多个名称/值对：{ &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; }这一点也容易理解，与这条 JavaScript 语句等价：firstName = &quot;John&quot;lastName = &quot;Doe&quot;JSON 数组 JSON 数组在方括号中书写：数组可包含多个对象：1234567&#123;&quot;employees&quot;: [&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Anna&quot; , &quot;lastName&quot;:&quot;Smith&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Peter&quot; , &quot;lastName&quot;:&quot;Jones&quot; &#125;]&#125; 在上面的例子中，对象 “employees” 是包含三个对象的数组。每个对象代表一条关于某人（有姓和名）的记录。JSON 使用 JavaScript 语法 因为 JSON 使用 JavaScript 语法，所以无需额外的软件就能处理 JavaScript 中的 JSON。通过 JavaScript，您可以创建一个对象数组，并像这样进行赋值：例子12345var employees = [&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,&#123; &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;: &quot;Carter&quot; &#125;]; 可以像这样访问 JavaScript 对象数组中的第一项：employees[0].lastName;返回的内容是：Gates可以像这样修改数据：employees[0].lastName = &quot;Jobs&quot;;","categories":[{"name":"Java web","slug":"Java-web","permalink":"http://liuzhe6.github.io/categories/Java-web/"}],"tags":[{"name":"json","slug":"json","permalink":"http://liuzhe6.github.io/tags/json/"}]},{"title":"一个jsp向另一个jsp传值","slug":"一个jsp向另一个jsp传值","date":"2017-01-06T13:31:42.000Z","updated":"2017-02-08T08:58:18.281Z","comments":true,"path":"2017/01/06/一个jsp向另一个jsp传值/","link":"","permalink":"http://liuzhe6.github.io/2017/01/06/一个jsp向另一个jsp传值/","excerpt":"","text":"一个jsp向另一个jsp传值 通过jsp的内置对象—request对象获取参数：（1）通过超链接传参：例：把a.jsp中i的值传到b.jsp中：在a.jsp页面中的核心代码为:传参 （说明：给i赋值时也可以用jsp表达式，例如i=&lt;%变量名 %&gt;)在b.jsp页面中的核心代码为： 12&lt;%String j=request.getParameter(&quot;i&quot;); %&gt;&lt;%=j %&gt; （2）通过request.setAttribute()方法：例：把a.jsp中表单中的name的值传送到b.jsp中： 在a.jsp页面中的核心代码为：&lt;%request.setAttribute(name,&quot;Danny&quot;);%&gt;在b.jsp页面中的核心代码为：&lt;%String getName=request.getParameter(&quot;name&quot;); %&gt; （3）通过表单传参：例：把a.jsp中表单中的name的值传送到b.jsp中：在a.jsp页面中的核心代码为： 重要的是，在jsp脚本中是无法使用EL表达式的，但是可以替换1234&lt;% request.setAttribute(&quot;username&quot;, request.getAttribute(&quot;username&quot;)); request.setAttribute(&quot;email&quot;, request.getAttribute(&quot;email&quot;));%&gt;","categories":[{"name":"Java web","slug":"Java-web","permalink":"http://liuzhe6.github.io/categories/Java-web/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://liuzhe6.github.io/tags/jsp/"}]},{"title":"JavaScript","slug":"JavaScript","date":"2017-01-06T13:15:55.000Z","updated":"2017-02-08T08:57:27.090Z","comments":true,"path":"2017/01/06/JavaScript/","link":"","permalink":"http://liuzhe6.github.io/2017/01/06/JavaScript/","excerpt":"","text":"JavaScriptJavaScript简介JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。在1995年时，由Netscape公司的Brendan Eich，在网景导航者浏览器上首次设计实现而成。因为Netscape与Sun合作，Netscape管理层希望它外观看起来像Java，因此取名为JavaScript。但实际上它的语法风格与Self及Scheme较为接近。为了取得技术优势，微软推出了JScript，CEnvi推出ScriptEase，与JavaScript同样可在浏览器上运行。为了统一规格，因为JavaScript兼容于ECMA标准，因此也称为ECMAScript。 戳这里 W3School学习网站 JavaScript：写入 HTML 输出实例12document.write(&quot;&lt;h1&gt;This is a heading&lt;/h1&gt;&quot;);document.write(&quot;&lt;p&gt;This is a paragraph&lt;/p&gt;&quot;); 提示：您只能在 HTML 输出中使用 document.write。如果您在文档加载后使用该方法，会覆盖整个文档。 JavaScript：对事件作出反应&lt;button type=&quot;button&quot; onclick=&quot;alert(&#39;Welcome!&#39;)&quot;&gt;点击这里&lt;/button&gt;alert() 函数在 JavaScript 中并不常用，但它对于代码测试非常方便。onclick 事件只是您即将在本教程中学到的众多事件之一。 JavaScript：改变 HTML 内容使用 JavaScript 来处理 HTML 内容是非常强大的功能。12x=document.getElementById(&quot;demo&quot;) //查找元素x.innerHTML=&quot;Hello JavaScript&quot;; //改变内容 您会经常看到 document.getElementByID(“some id”)。这个方法是 HTML DOM 中定义的。DOM（文档对象模型）是用以访问 HTML 元素的正式 W3C 标准。您将在本教程的多个章节中学到有关 HTML DOM 的知识。 JavaScript 与 Java 是两种完全不同的语言，无论在概念还是设计上。","categories":[{"name":"Java web","slug":"Java-web","permalink":"http://liuzhe6.github.io/categories/Java-web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://liuzhe6.github.io/tags/JavaScript/"}]},{"title":"JSP","slug":"JSP","date":"2017-01-06T12:45:24.000Z","updated":"2017-02-08T08:57:52.522Z","comments":true,"path":"2017/01/06/JSP/","link":"","permalink":"http://liuzhe6.github.io/2017/01/06/JSP/","excerpt":"","text":"JSP简介什么是JSPJSP全名为Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servlet设计，它[1] 是由Sun Microsystems公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP技术有点类似ASP技术，它是在传统的网页HTML（标准通用标记语言的子集）文件(.htm,.html)中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。 用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。 它实现了Html语法中的java扩展（以 &lt;%, %&gt;形式）。JSP与Servlet一样，是在服务器端执行的。通常返回给客户端的就是一个HTML文本，因此客户端只要有浏览器就能浏览。 Java Servlet是JSP的技术基础，而且大型的Web应用程序的开发需要Java Servlet和JSP配合才能完成。JSP具备了Java技术的简单易用，完全的面向对象，具有平台无关性且安全可靠，主要面向因特网的所有特点。 (详细介绍请查阅相关资料 这里就不一一介绍了) 第一个JSP第一个JSP程序语言学习入门的第一个程序一般都是输出”Hello World！”，JSP输出”Hello World！”代码如下所示:12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;第一个JSP程序&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% out.println(&quot;Hello World！&quot;); %&gt; &lt;/body&gt;&lt;/html&gt; JSP语法脚本程序脚本程序可以包含任意量的Java语句、变量、方法或表达式，只要它们在脚本语言中是有效的。脚本程序的语法格式：&lt;% 代码片段 %&gt;或者，您也可以编写与其等价的XML语句，就像下面这样： 代码片段任何文本、HTML标签、JSP元素必须写在脚本程序的外面。下面给出一个示例，同时也是本教程的第一个JSP示例：123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;br/&gt;&lt;%out.println(&quot;Your IP address is &quot; + request.getRemoteAddr());%&gt;&lt;/body&gt;&lt;/html&gt; 中文编码问题的解决如果我们要在页面正常显示中文，我们需要在 JSP 文件头部添加以下代码：&lt;&gt;12&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; 接下来我们将以上程序修改为：123456789101112131415&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;br/&gt;&lt;%out.println(&quot;你的 IP 地址 &quot; + request.getRemoteAddr());%&gt;&lt;/body&gt;&lt;/html&gt; 这样中文就可以正常显示了。 JSP表达式一个JSP表达式中包含的脚本语言表达式，先被转化成String，然后插入到表达式出现的地方。由于表达式的值会被转化成String，所以您可以在一个文本行中使用表达式而不用去管它是否是HTML标签。表达式元素中可以包含任何符合Java语言规范的表达式，但是不能使用分号来结束表达式。JSP表达式的语法格式：&lt;%= 表达式 %&gt;程序示例：1234567891011121314&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt; 今天的日期是: &lt;%= (new java.util.Date()).toLocaleString()%&gt;&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; JSP注释123456789101112131415&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%-- 该部分注释在网页中不会被显示--%&gt; &lt;p&gt; 今天的日期是: &lt;%= (new java.util.Date()).toLocaleString()%&gt;&lt;/p&gt;&lt;/body&gt; &lt;/html&gt; 运行后得到以下结果：今天的日期是: 2017-1-6 20:39:30不同情况下使用注释的语法规则： 语法 描述 &lt;%– 注释 –%&gt; JSP注释，注释内容不会被发送至浏览器甚至不会被编译 HTML注释，通过浏览器查看网页源代码时可以看见注释内容 &lt;\\% 代表静态 &lt;%常量 %> 代表静态 %&gt; 常量 \\’ 在属性中使用的单引号 \\” 在属性中使用的双引号 JSP指令JSP指令用来设置与整个JSP页面相关的属性。JSP指令语法格式：&lt;%@ directive attribute=&quot;value&quot; %&gt; 指令 描述 &lt;%@ page … %&gt; 定义页面的依赖属性，比如脚本语言、error页面、缓存需求等等 &lt;%@ include … %&gt; 包含其他文件 &lt;%@ taglib … %&gt; 引入标签库的定义，可以是自定义标签","categories":[{"name":"Java web","slug":"Java-web","permalink":"http://liuzhe6.github.io/categories/Java-web/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://liuzhe6.github.io/tags/jsp/"}]},{"title":"jsp使用项目路径之外的图片方法","slug":"jsp使用项目路径之外的图片方法","date":"2016-08-06T10:21:53.000Z","updated":"2017-02-08T08:57:58.000Z","comments":true,"path":"2016/08/06/jsp使用项目路径之外的图片方法/","link":"","permalink":"http://liuzhe6.github.io/2016/08/06/jsp使用项目路径之外的图片方法/","excerpt":"","text":"一个java web项目，把图片放在项目目录或者tomcat目录 可能会出现一些问题，那么我们可以放在项目目录之外，甚至可以放到不同的磁盘上，那么就需要在tomcat设置虚拟目录。 在tomcat的conf/server.xml中设置虚拟路径在tomcat下的conf/server.xml中增加一个代码 在中间如下： 12&lt;!--增加的--path=&quot;/虚拟名&quot; docBase=&quot;虚拟路径&quot; -&gt; &lt;Context path=&quot;/virtual&quot; docBase=&quot;D:\\upload\\&quot; reloadable=&quot;true&quot;&gt;&lt;/Context&gt; 在jsp中这样使用 1&lt;img src=&quot;/virtual/1.jsp&quot;&gt;","categories":[{"name":"Java web","slug":"Java-web","permalink":"http://liuzhe6.github.io/categories/Java-web/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://liuzhe6.github.io/tags/jsp/"}]},{"title":"JFinal上传图片及其重命名","slug":"JFinal上传图片及其重命名","date":"2016-08-01T09:34:12.000Z","updated":"2017-02-08T08:57:34.324Z","comments":true,"path":"2016/08/01/JFinal上传图片及其重命名/","link":"","permalink":"http://liuzhe6.github.io/2016/08/01/JFinal上传图片及其重命名/","excerpt":"","text":"一、表单处理12345&lt;form action=&quot;applicant/changeInformation&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; &gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot;/&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot;/&gt;&lt;/form&gt; 二、在后台的配置我们需要在Controller中得到表单里的三个东西，因为我们在客户端的请求为multipart request(form 表单使用了enctype=”multipart/form-data”)， 那么必须先调用getFile系列的方法才能使用getPara系列的方法正常工作，因为multipart request需要通过getFile系列方法解析请求体中的数据，包括参数 我们设置上传文件的路径为“D:/Activity_Registration_System/user_img”那么，在jfinal的config中设置一个基础上传路径 123456789@Overridepublic void configConstant(Constants me) &#123; // TODO Auto-generated method stub PropKit.use(&quot;SQLConfig.txt&quot;); me.setDevMode(PropKit.getBoolean(&quot;devMode&quot;)); me.setViewType(ViewType.JSP); //设置上传的基础路径,设置在D盘的Activity_Registration_System文件夹下面 me.setBaseUploadPath(&quot;D:/Activity_Registration_System/&quot;);&#125; 三、在Controller里的配置接下来，在Controller里面得到文件以及数据，并把文件保存在这个目录下1234//先使用getFile()获得上传的文件,并存在 基础路径+user_img 这个绝对路径下面String realpath = &quot;user_img&quot;;UploadFile uf = getFile(&quot;header&quot;,realpath); 接下来获取其他数据1234String username = getPara(&quot;username&quot;);System.out.println(&quot;username:&quot;+username);String email = getPara(&quot;email&quot;);System.out.println(&quot;email:&quot;+email); 四、对刚刚已经上传成功的文件进行重命名12345678910111213141516171819//首先我们要获取文件的拓展名，所以要把文件原名称进行拆分String fileName = file.getName();String extName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)+ 1); //获取拓展名,按照 &quot;.&quot; 分隔开的最后一个字符串//接下来，获取刚刚上传的文件的局对路径String [] test = file.getPath().split(&quot;user_img&quot;);//这里之所以按user_img 进行分割是因为有个bug 如果按照\\进行分割，则应写为spilt(&quot;\\\\&quot;) 但是编译器会解析为按字符串\\\\进行分割，所以会出现问题String road = &quot;&quot;; for (int i = 0 ;i &lt; test.length;i++)&#123; if (i == test.length-1)&#123; break; &#125; road += test[i]; &#125; road += &quot;user_img\\\\&quot; + getSessionAttr(&quot;student_id&quot;)+&quot;.&quot; + extName;//我这里按照学号进行命名//此时road的值为 文件的 绝对路径 + 新名称file.renameTo(new File(road)); 这样，简单的单文件、数据上传以及重命名就完成了。 这是我的第一篇博客，欢迎大家批评指正","categories":[{"name":"Java web","slug":"Java-web","permalink":"http://liuzhe6.github.io/categories/Java-web/"}],"tags":[{"name":"JFinal","slug":"JFinal","permalink":"http://liuzhe6.github.io/tags/JFinal/"}]}]}